
GeneralizedChebyshev := module()
description "A collection of procedures for generalized Chebyshev Polynomials";
option package;

with(LinearAlgebra):

export Base, coroot, WeightMatrix, FWeight, RWeylGroupGen, ZWeylGroupGen, FundomVertexCoefficient, VertexFundom, VertexTOrbitSpace, FundamentalInvariant, HighestRoot, ChebyshevLevel, ROrbit, ZOrbit, GeneralizedCosine, RGeneralizedCosine, TMultiply, TPoly, TPolyRecurrence, HermiteMatrix, RHermiteMatrix, InvariantRewrite, THermiteMatrix, RTHermiteMatrix, TLocalizedPMI, TArchimedeanPMI, ChebyshevSDPdata, ChebyshevArchimedeanSDP, Pull, RPull, TruncatedTMomentMatrix;

local Reflection, RWeylGroup, ZWeylGroup, esp, MonomialMultiply, ChebyshevDegExp, TruncatedMonomialMomentMatrix, PrimalConstraintMatrix, DualConstraintMatrix, MonomialExponent, SolutionSet, MonomialExponent2, MonomialRewrite, MonomialHermiteMatrix, MonomialLocalizedPMI, CoeffInMatrix, THermiteEntries, RTHermiteEntriesOld, RTHermiteEntries;

Base:=proc(Type,n) # base of a root system
local i, j;
 if   Type = A then
  [seq([seq(`if`(j=i,1,`if`(j=i+1,-1,0)),j=1..n+1)],i=1..n)]
 elif Type = B then
  [seq([seq(`if`(j=i,1,`if`(j=i+1,-1,0)),j=1..n)],i=1..n)]
 elif Type = C then
  [seq([seq(`if`(j=i,1,`if`(j=i+1,-1,0)),j=1..n)],i=1..n-1),[seq(0,i=1..n-1),2]]
 elif Type = D then
  [seq([seq(`if`(j=i,1,`if`(j=i+1,-1,0)),j=1..n)],i=1..n-1),[seq(`if`(j=n,1,`if`(j=n-1,1,0)),j=1..n)]]
 elif Type = E and 6 <= n and n <= 8 then
  [[1,-1,-1,-1,-1,-1,-1,1]/2,[1,1,seq(0,j=3..8)],seq([seq(`if`(j=i-1,1,`if`(j=i-2,-1,0)),j=1..8)],i=3..n)]
 elif Type = F and n = 4 then
  [[0,1,-1,0],[0,0,1,-1],[0,0,0,1],[1,-1,-1,-1]/2]
 elif Type = G and n = 2 then
  [[1,-1,0],[-2,1,1]]
 else
  printf("Error: root system must be of simple Lie type")
 fi;
end proc:

coroot:=proc(r::list) # coroot of the input
 local scalar, i;
 scalar:=convert([seq(r[i]^2,i=1..nops(r))],`+`);
 2/scalar*r;
end proc:

WeightMatrix:=proc(Type,n) # the matrix containing the fundamental weights as columns
 MatrixInverse(Matrix(map(v->coroot(v),Base(Type,n))))
end proc:

FWeight:=proc(Type,n) # the list of fundamental weights
local i;
 [seq(convert(Column(WeightMatrix(Type,n),i),list),i=1..n)]
end proc:

HighestRoot:=proc(Type,n)
local i, j;
 if   Type = A then
  FWeight(Type,n)[1]+FWeight(Type,n)[n]
 elif Type = B then
  Base(Type,n)[1] + 2*convert([seq(Base(Type,n)[j],j=2..n)],`+`)
 elif Type = C then
  2*FWeight(Type,n)[1]
 elif Type = D then
  Base(Type,n)[1] + 2*convert([seq(Base(Type,n)[j],j=2..n-2)],`+`) + Base(Type,n)[n-1] + Base(Type,n)[n]
 elif Type = E and n = 6 then
  FWeight(Type,n)[2]
 elif Type = E and n = 7 then
  FWeight(Type,n)[1]
 elif Type = E and n = 8 then
  FWeight(Type,n)[8]
 elif Type = F and n = 4 then
  FWeight(Type,n)[1]
 elif Type = G and n = 2 then
  FWeight(Type,n)[2]
 else
  printf("Error: root system must be of simple Lie type")
 fi;
end proc:

FundomVertexCoefficient:=proc(Type,n) # fundamental domain is convex hull of 0 and fundamental weights, divided by some scalars. this is the list of scalar divisors (!!!)
local i;
 [op(convert(Transpose(<op(HighestRoot(Type,n))>).WeightMatrix(Type,n),list)),1]
end proc:

RWeylGroupGen:=proc(Type,n) option remember; # generators of the Weyl group as a real orthogonal matrix group
 local i, j, k, N, diag;
 if   Type = A then
  [seq(Matrix([seq([seq(`if`(i=k,1,0),i=1..n+1)],k=1..j-1),[seq(`if`(i=j+1,1,0),i=1..n+1)],[seq(`if`(i=j,1,0),i=1..n+1)],seq([seq(`if`(i=k,1,0),i=1..n+1)],k=j+2..n+1)]),j=1..n)];
 elif Type = B or Type = C or Type = D or Type = F then
  for i from 1 to n do
   N[i]:=Matrix([seq(`if`(j=i,Base(Type,n)[j],FWeight(Type,n)[j]),j=1..n)]):
  od:
  for i from 1 to n do
   diag[i]:=Matrix([seq(`if`(j=i,[seq(`if`(k=j,-1,0),k=1..n)],[seq(`if`(k=j,1,0),k=1..n)]),j=1..n)]):
  od:
  for i from 1 to n do
   [seq(Transpose(N[i]^(-1).diag[i].N[i]),i=1..n)]
  od:
 elif Type = G and n = 2 then
  [Matrix(3, 3, [[0, 1, 0], [1, 0, 0], [0, 0, 1]]), Matrix(3, 3, [[-1/3, 2/3, 2/3], [2/3, 2/3, -1/3], [2/3, -1/3, 2/3]])]
 else
  printf("Error: root system must be of Type A, B, C, D, F, G")
 fi;
end proc:

RWeylGroup:=proc(Type,n) option remember; # the Weyl group as a real orthogonal matrix group
 local W;
 W:=GroupTheory[Group]({op(RWeylGroupGen(Type,n))});
 return [op(Elements(W))];
end proc:

ZWeylGroupGen:=proc(Type,n) option remember; # the Weyl group as an integer matrix group
 local mat;
 map(mat-> MatrixInverse(WeightMatrix(Type,n)).mat.WeightMatrix(Type,n),RWeylGroupGen(Type,n));
end proc:

ZWeylGroup:=proc(Type,n) option remember; # the Weyl group as an integer matrix group
 local W;
 W:=GroupTheory[Group]({op(ZWeylGroupGen(Type,n))});
 return [op(Elements(W))];
end proc:

Reflection:=proc(rho,omega)  
 omega - ListTools[DotProduct](coroot(rho),omega)*rho;
end:

ROrbit:=proc(Type,n,omega) option remember;
 local Orb, i, stack_omega, next_omega, new_omega;
 Orb := {omega};
 stack_omega := stack[new](omega);
 while (not stack[empty](stack_omega)) do
  next_omega := stack[pop](stack_omega);
  for i from 1 to n do
   new_omega := Reflection(Base(Type,n)[i],next_omega);
   if (not (new_omega in Orb)) then
    Orb := Orb union {new_omega};
    stack[push](new_omega, stack_omega);
   end if;
  od;
 od;
 Orb := [op(simplify(Orb))];
end proc:

ZOrbit:=proc(Type,alpha) option remember; 
 local n, v;
 n:=nops(alpha);
 map(v->convert(MatrixInverse(WeightMatrix(Type,n)).<v>,list),ROrbit(Type,n,convert(WeightMatrix(Type,n).<alpha>,list)))
end proc:

FundamentalInvariant:=proc(Type,n) option remember; # as Laurent polynomials
 local i, j, k, l, orb;
 global x;
 x:='x';
 if Type=A then
  [seq(expand(binomial(n+1,l)^(-1)*esp([x[1],seq(x[k]*x[k-1]^(-1),k=2..n),x[n]^(-1)],l)),l=1..n)]
 elif Type=C then
  [seq(expand(binomial(n,l)^(-1)*2^(-l)*esp([x[1]+x[1]^(-1),seq(x[k]*x[k-1]^(-1)+x[k]^(-1)*x[k-1],k=2..n)],l)),l=1..n)]
 elif Type=B then
  [seq(expand(binomial(n,l)^(-1)*2^(-l)*esp([x[1]+x[1]^(-1),seq(x[k]*x[k-1]^(-1)+x[k]^(-1)*x[k-1],k=2..n-1),x[n]^2*x[n-1]^(-1)+x[n]^(-2)*x[n-1]],l)),l=1..n-1),expand(2^(-n)*convert(map(orb->convert([seq(x[l]^(orb[l]),l=1..n)],`*`),ZOrbit(Type,[seq(0,k=1..n-1),1])),`+`))]
 elif Type=D then
  [seq(expand(binomial(n,l)^(-1)*2^(-l)*esp([x[1]+x[1]^(-1),seq(x[k]*x[k-1]^(-1)+x[k]^(-1)*x[k-1],k=2..n-2),x[n]*x[n-1]*x[n-2]^(-1)+x[n]^(-1)*x[n-1]^(-1)*x[n-2],x[n]*x[n-1]^(-1)+x[n]^(-1)*x[n-1]],l)),l=1..n-2),expand(2^(1-n)*convert(map(orb->convert([seq(x[l]^(orb[l]),l=1..n)],`*`),ZOrbit(Type,[seq(0,k=1..n-2),1,0])),`+`)),expand(2^(1-n)*convert(map(orb->convert([seq(x[l]^(orb[l]),l=1..n)],`*`),ZOrbit(Type,[seq(0,k=1..n-1),1])),`+`))]
 elif Type=F and n=4 then
  [x[2]/x[1]^2 + x[3]^2/(x[1]*x[2]) + 1/x[1] + x[4]^2/x[1] + x[3]^2/(x[1]*x[4]^2) + x[2]*x[4]^2/(x[1]*x[3]^2) + x[2]/(x[1]*x[4]^2) + x[2]/x[1] + x[2]^2/(x[1]*x[3]^2) + x[4]^2/x[2] + x[3]^2/(x[2]*x[4]^2) + x[3]^2/x[2] + x[2]/x[3]^2 + x[2]*x[4]^2/x[3]^2 + x[2]/x[4]^2 + x[1]*x[3]^2/x[2]^2 + x[1]/x[2] + x[1]*x[4]^2/x[2] + x[1]*x[3]^2/(x[2]*x[4]^2) + x[1]*x[4]^2/x[3]^2 + x[1]/x[4]^2 + x[1] + x[1]*x[2]/x[3]^2 + x[1]^2/x[2],
   x[1]*x[2]*x[4]^4/x[3]^4 + x[1]*x[2]/(x[3]^2*x[4]^2) + x[1]*x[2]*x[4]^2/x[3]^2 + x[1]*x[2]/x[4]^4 + x[1]*x[2]/x[4]^2 + x[1]*x[2]^2/x[3]^4 + x[1]*x[2]^2*x[4]^2/x[3]^4 + x[1]*x[2]^2/(x[3]^2*x[4]^2) + x[1]^2*x[3]^2/x[2]^3 + x[1]^2*x[3]^2*x[4]^2/x[2]^3 + x[1]^2*x[3]^4/(x[2]^3*x[4]^2) + x[1]^2*x[4]^2/(x[2]*x[3]^2) + x[1]^2*x[4]^4/(x[2]*x[3]^2) + x[1]^2/(x[2]*x[4]^2) + x[1]^2*x[4]^2/x[2] + x[1]^2*x[3]^2/(x[2]*x[4]^4) + x[1]^2*x[3]^2/(x[2]*x[4]^2) + x[1]^2*x[2]*x[4]^2/x[3]^4 + x[1]^2*x[2]/(x[3]^2*x[4]^2) + x[1]^2*x[2]/x[3]^2 + x[1]^3*x[3]^2/x[2]^3 + x[1]^3*x[4]^2/x[2]^2 + x[1]^3*x[3]^2/(x[2]^2*x[4]^2) + x[1]^3*x[4]^2/(x[2]*x[3]^2) + x[1]^3/(x[2]*x[4]^2) + x[1]^3/x[3]^2 + x[3]^4/(x[1]*x[2]^2*x[4]^2) + x[3]^4/(x[1]*x[2]^2) + x[4]^2/(x[1]*x[2]) + x[4]^4/(x[1]*x[2]) + x[3]^2/(x[1]*x[2]*x[4]^2) + x[3]^2*x[4]^2/(x[1]*x[2]) + x[3]^4/(x[1]*x[2]*x[4]^4) + x[3]^4/(x[1]*x[2]*x[4]^2) + x[4]^4/(x[1]*x[3]^2) + x[3]^2/(x[1]*x[4]^4) + x[3]^2/x[1] + x[2]/(x[1]*x[3]^2) + x[2]*x[4]^4/(x[1]*x[3]^2) + x[2]*x[3]^2/(x[1]*x[4]^4) + x[2]^2*x[4]^2/(x[1]*x[3]^4) + x[2]^2*x[4]^4/(x[1]*x[3]^4) + x[2]^2/(x[1]*x[3]^2*x[4]^2) + x[2]^2*x[4]^2/(x[1]*x[3]^2) + x[2]^2/(x[1]*x[4]^4) + x[2]^2/(x[1]*x[4]^2) + x[2]^3/(x[1]*x[3]^4) + x[2]^3*x[4]^2/(x[1]*x[3]^4) + x[2]^3/(x[1]*x[3]^2*x[4]^2) + x[1]*x[3]^2*x[4]^2/x[2]^3 + x[1]*x[3]^4/(x[2]^3*x[4]^2) + x[1]*x[3]^4/x[2]^3 + x[1]*x[4]^2/x[2]^2 + x[1]*x[4]^4/x[2]^2 + x[1]*x[3]^2/(x[2]^2*x[4]^2) + x[1]*x[3]^2*x[4]^2/x[2]^2 + x[1]*x[3]^4/(x[2]^2*x[4]^4) + x[1]*x[3]^4/(x[2]^2*x[4]^2) + x[1]*x[4]^4/(x[2]*x[3]^2) + x[1]*x[3]^2/(x[2]*x[4]^4) + x[1]*x[3]^2/x[2] + x[1]/x[3]^2 + x[1]*x[4]^4/x[3]^2 + x[1]*x[3]^2/x[4]^4 + x[1]*x[2]*x[4]^2/x[3]^4 + x[3]^2/x[1]^3 + x[2]*x[4]^2/x[1]^3 + x[2]*x[3]^2/(x[1]^3*x[4]^2) + x[2]^2*x[4]^2/(x[1]^3*x[3]^2) + x[2]^2/(x[1]^3*x[4]^2) + x[2]^3/(x[1]^3*x[3]^2) + x[3]^2/(x[1]^2*x[2]) + x[3]^2*x[4]^2/(x[1]^2*x[2]) + x[3]^4/(x[1]^2*x[2]*x[4]^2) + x[2]*x[4]^2/(x[1]^2*x[3]^2) + x[2]*x[4]^4/(x[1]^2*x[3]^2) + x[2]/(x[1]^2*x[4]^2) + x[2]*x[4]^2/x[1]^2 + x[2]*x[3]^2/(x[1]^2*x[4]^4) + x[2]*x[3]^2/(x[1]^2*x[4]^2) + x[2]^3*x[4]^2/(x[1]^2*x[3]^4) + x[2]^3/(x[1]^2*x[3]^2*x[4]^2) + x[2]^3/(x[1]^2*x[3]^2) + x[3]^2*x[4]^2/(x[1]*x[2]^2) + x[3]^4/x[2]^3 + x[4]^4/x[2] + x[3]^4/(x[2]*x[4]^4) + x[2]*x[4]^4/x[3]^4 + x[2]/x[4]^4 + x[2]^3/x[3]^4 + x[2] + x[2]^2/x[1]^3 + x[1]^3/x[2] + x[1]^3/x[2]^2 + x[2]/x[1]^3 + 1/x[2],
   x[1]*x[3]^2*x[4]/x[2]^2 + x[1]*x[3]^3/(x[2]^2*x[4]^2) + x[1]*x[3]^3/(x[2]^2*x[4]) + x[1]*x[4]^2/(x[2]*x[3]) + x[1]*x[4]^3/(x[2]*x[3]) + x[1]*x[3]/(x[2]*x[4]^2) + x[1]*x[3]*x[4]/x[2] + x[1]*x[3]^2/(x[2]*x[4]^3) + x[1]*x[3]^2/(x[2]*x[4]) + x[1]*x[4]/x[3]^2 + x[1]*x[4]^3/x[3]^2 + x[1]/(x[3]*x[4]) + x[1]*x[4]^2/x[3] + x[1]*x[3]/x[4]^3 + x[1]*x[3]/x[4]^2 + x[1]*x[2]*x[4]/x[3]^3 + x[1]*x[2]*x[4]^2/x[3]^3 + x[1]*x[2]/(x[3]^2*x[4]) + x[1]*x[2]*x[4]/x[3]^2 + x[1]*x[2]/(x[3]*x[4]^2) + x[1]*x[2]/(x[3]*x[4]) + x[1]^2*x[3]/x[2]^2 + x[1]^2*x[3]*x[4]/x[2]^2 + x[1]^2*x[3]^2/(x[2]^2*x[4]) + x[1]^2*x[4]/(x[2]*x[3]) + x[1]^2*x[4]^2/(x[2]*x[3]) + x[1]^2/(x[2]*x[4]) + x[1]^2*x[4]/x[2] + x[1]^2*x[3]/(x[2]*x[4]^2) + x[1]^2*x[3]/(x[2]*x[4]) + x[1]^2*x[4]/x[3]^2 + x[1]^2/(x[3]*x[4]) + x[1]^2/x[3] + x[2]*x[4]^2/(x[1]^2*x[3]) + x[2]/(x[1]^2*x[4]) + x[2]*x[4]/x[1]^2 + x[2]*x[3]/(x[1]^2*x[4]^2) + x[2]*x[3]/(x[1]^2*x[4]) + x[2]^2*x[4]/(x[1]^2*x[3]^2) + x[2]^2/(x[1]^2*x[3]*x[4]) + x[2]^2/(x[1]^2*x[3]) + x[3]*x[4]/(x[1]*x[2]) + x[3]*x[4]^2/(x[1]*x[2]) + x[3]^2/(x[1]*x[2]*x[4]) + x[3]^2*x[4]/(x[1]*x[2]) + x[3]^3/(x[1]*x[2]*x[4]^2) + x[3]^3/(x[1]*x[2]*x[4]) + x[4]^2/(x[1]*x[3]) + x[4]^3/(x[1]*x[3]) + x[3]/(x[1]*x[4]^2) + x[3]*x[4]/x[1] + x[3]^2/(x[1]*x[4]^3) + x[3]^2/(x[1]*x[4]) + x[2]*x[4]/(x[1]*x[3]^2) + x[2]*x[4]^3/(x[1]*x[3]^2) + x[2]/(x[1]*x[3]*x[4]) + x[2]*x[4]^2/(x[1]*x[3]) + x[2]*x[3]/(x[1]*x[4]^3) + x[2]*x[3]/(x[1]*x[4]^2) + x[2]^2*x[4]/(x[1]*x[3]^3) + x[2]^2*x[4]^2/(x[1]*x[3]^3) + x[2]^2/(x[1]*x[3]^2*x[4]) + x[2]^2*x[4]/(x[1]*x[3]^2) + x[2]^2/(x[1]*x[3]*x[4]^2) + x[2]^2/(x[1]*x[3]*x[4]) + x[1]*x[3]*x[4]/x[2]^2 + x[1]*x[3]*x[4]^2/x[2]^2 + x[1]*x[3]^2/(x[2]^2*x[4]) + x[3]/x[1]^2 + x[3]*x[4]/x[1]^2 + x[3]^2/(x[1]^2*x[4]) + x[2]*x[4]/(x[1]^2*x[3]) + x[3] + 1/x[3] + x[3]^2*x[4]/x[2]^2 + x[3]^3/(x[2]^2*x[4]) + x[3]^3/x[2]^2 + x[4]/x[2] + x[4]^3/x[2] + x[3]/(x[2]*x[4]) + x[3]*x[4]^2/x[2] + x[3]^3/(x[2]*x[4]^3) + x[3]^3/(x[2]*x[4]^2) + x[2]*x[4]^2/x[3]^3 + x[2]*x[4]^3/x[3]^3 + x[2]/(x[3]*x[4]^2) + x[2]*x[4]/x[3] + x[2]/x[4]^3 + x[2]/x[4] + x[2]^2/x[3]^3 + x[2]^2*x[4]/x[3]^3 + x[2]^2/(x[3]^2*x[4]) + x[4]^3/x[3]^2 + x[4]^3/x[3] + x[3]/x[4]^3 + x[3]^2/x[4]^3,
   x[4]/x[1] + x[3]/(x[1]*x[4]) + x[3]/x[1] + x[2]/(x[1]*x[3]) + x[2]*x[4]/(x[1]*x[3]) + x[2]/(x[1]*x[4]) + x[3]/x[2] + x[3]*x[4]/x[2] + x[3]^2/(x[2]*x[4]) + x[4]/x[3] + x[4]^2/x[3] + 1/x[4] + x[4] + x[3]/x[4]^2 + x[3]/x[4] + x[2]*x[4]/x[3]^2 + x[2]/(x[3]*x[4]) + x[2]/x[3] + x[1]*x[4]/x[2] + x[1]*x[3]/(x[2]*x[4]) + x[1]*x[3]/x[2] + x[1]/x[3] + x[1]*x[4]/x[3] + x[1]/x[4]]
 elif Type=E and n=6 then
  [x[2]/(27*x[6]) + x[2]*x[6]/(27*x[5]) + x[4]/(27*x[2]*x[6]) + x[2]*x[5]/(27*x[4]) + x[5]/(27*x[2]) + x[4]*x[6]/(27*x[2]*x[5]) + x[4]/(27*x[2]*x[3]) + x[1]*x[4]/(27*x[3]*x[5]) + x[1]*x[2]/(27*x[4]) + x[1]*x[6]/(27*x[3]) + x[1]*x[5]/(27*x[3]*x[6]) + x[5]/(27*x[1]*x[6]) + x[4]/(27*x[1]*x[5]) + x[2]*x[3]/(27*x[1]*x[4]) + 1/(27*x[6]) + x[3]/(27*x[1]*x[2]) + x[6]/(27*x[1]) + x[3]/(27*x[5]) + x[6]/(27*x[5]) + x[5]/(27*x[4]) + x[3]/(27*x[1]) + x[4]/(27*x[3]) + x[2]/(27*x[3]) + x[3]*x[6]/(27*x[4]) + x[3]*x[5]/(27*x[4]*x[6]) + x[1]/(27*x[2]) + x[1]/27,
    x[1]^2/(72*x[3]) + x[3]/(72*x[1]^2) + x[3]^2/(72*x[1]*x[4]) + x[2]/72 + x[1]*x[4]/(72*x[3]^2) + x[4]/(72*x[2]) + x[2]/(72*x[4]) + x[3]/(72*x[6]) + x[3]*x[6]/(72*x[5]) + x[4]*x[6]/(72*x[1]*x[2]*x[5]) + 1/(72*x[2]) + x[1]*x[4]/(72*x[2]*x[5]) + x[1]*x[5]/(72*x[2]*x[6]) + x[5]/(72*x[1]*x[2]) + x[1]*x[2]/(72*x[3]*x[6]) + x[1]*x[6]/(72*x[2]) + x[2]*x[3]/(72*x[1]*x[5]) + x[1]*x[2]*x[5]/(72*x[3]*x[4]) + x[1]*x[2]*x[6]/(72*x[3]*x[5]) + x[2]*x[3]*x[6]/(72*x[1]*x[4]) + x[2]*x[3]*x[5]/(72*x[1]*x[4]*x[6]) + x[5]/(72*x[1]) + x[4]*x[6]/(72*x[1]*x[5]) + x[4]/(72*x[1]*x[6]) + x[1]*x[4]*x[6]/(72*x[2]*x[3]*x[5]) + x[1]*x[4]/(72*x[2]*x[3]*x[6]) + x[1]*x[6]/(72*x[4]) + x[1]*x[5]/(72*x[4]*x[6]) + x[1]/(72*x[5]) + x[2]^2/(72*x[4]) + x[2]*x[4]/(72*x[3]*x[5]) + x[2]*x[5]/(72*x[3]*x[6]) + x[2]*x[6]/(72*x[3]) + x[2]*x[3]/(72*x[4]*x[6]) + x[2]*x[3]*x[6]/(72*x[4]*x[5]) + x[2]*x[3]*x[5]/(72*x[4]^2) + x[4]^2/(72*x[2]*x[3]*x[5]) + x[4]*x[5]/(72*x[2]*x[3]*x[6]) + x[4]*x[6]/(72*x[2]*x[3]) + x[3]/(72*x[2]*x[6]) + x[3]*x[6]/(72*x[2]*x[5]) + x[3]*x[5]/(72*x[2]*x[4]) + x[4]/(72*x[2]^2) + x[1]*x[5]/(72*x[2]*x[3]) + x[3]*x[4]/(72*x[1]*x[2]*x[5]) + x[3]*x[5]/(72*x[1]*x[2]*x[6]) + x[3]*x[6]/(72*x[1]*x[2]) + x[5]/(72*x[6]^2) + x[6]^2/(72*x[5]) + x[4]*x[6]/(72*x[5]^2) + x[5]*x[6]/(72*x[4]) + x[5]^2/(72*x[4]*x[6]) + x[4]/(72*x[5]*x[6]) + x[2]/(72*x[1]*x[6]) + x[2]*x[6]/(72*x[1]*x[5]) + x[1]*x[2]/(72*x[5]) + x[2]*x[5]/(72*x[1]*x[4]) + x[1]*x[2]*x[5]/(72*x[4]*x[6]) + x[1]*x[2]*x[6]/(72*x[4]) + x[4]/(72*x[1]*x[3]) + x[1]*x[4]/(72*x[3]*x[6]) + x[1]*x[4]*x[6]/(72*x[3]*x[5]) + x[1]*x[5]/(72*x[3]) + x[3]*x[5]/(72*x[1]*x[4]*x[6]) + x[3]/(72*x[1]*x[5]) + x[3]*x[6]/(72*x[1]*x[4]) + x[1]*x[3]/(72*x[4]) + x[4]/(72*x[1]*x[2]*x[6]) + x[4]/(72*x[3]*x[5]) + x[3]*x[5]/(72*x[4]) + x[5]/(72*x[3]*x[6]) + x[6]/(72*x[3]),
    x[1]*x[2]*x[3]*x[5]/(216*x[4]^2*x[6]) + x[1]*x[2]*x[3]*x[6]/(216*x[4]^2) + x[4]/(216*x[1]^2*x[6]) + x[4]*x[6]/(216*x[1]^2*x[5]) + x[4]/(216*x[6]^2) + x[4]*x[6]^2/(216*x[5]^2) + x[5]^2/(216*x[4]) + x[5]/(216*x[4]*x[6]) + x[2]*x[3]*x[6]/(216*x[1]^2*x[4]) + x[2]*x[3]/(216*x[1]*x[4]*x[6]) + x[2]*x[3]*x[6]/(216*x[1]*x[4]*x[5]) + x[1]*x[2]*x[3]/(216*x[4]*x[5]) + x[2]*x[3]*x[5]/(216*x[1]*x[4]^2) + x[1]*x[4]/(216*x[3]*x[5]*x[6]) + x[1]*x[4]*x[6]/(216*x[3]*x[5]^2) + x[2]*x[5]/(216*x[1]*x[6]^2) + x[1]^2*x[5]/(216*x[3]*x[6]) + x[1]*x[5]/(216*x[3]*x[6]^2) + x[1]^2*x[6]/(216*x[3]) + x[1]*x[2]/(216*x[6]) + x[2]*x[6]^2/(216*x[1]*x[5]) + x[1]*x[2]*x[6]/(216*x[5]) + x[2]*x[5]^2/(216*x[1]*x[4]*x[6]) + x[1]*x[2]*x[6]/(216*x[3]^2) + x[2]^2*x[3]/(216*x[1]*x[4]*x[6]) + x[3]*x[5]/(216*x[1]*x[2]^2) + x[2]^2/(216*x[1]*x[4]) + x[4]^2/(216*x[3]*x[5]^2) + x[5]^2/(216*x[3]*x[6]^2) + x[6]^2/(216*x[3]) + x[2]*x[3]*x[5]/(216*x[1]^2*x[4]*x[6]) + 1/(216*x[5]) + x[3]^2*x[6]/(216*x[1]*x[2]*x[4]) + x[3]*x[4]/(216*x[1]*x[2]^2*x[6]) + x[3]*x[4]*x[6]/(216*x[1]*x[2]^2*x[5]) + x[1]*x[6]^2/(216*x[3]*x[5]) + x[1]*x[5]^2/(216*x[3]*x[4]*x[6]) + x[2]*x[3]^2/(216*x[1]*x[4]*x[5]) + x[1]*x[5]*x[6]/(216*x[3]*x[4]) + x[1]*x[4]^2/(216*x[2]*x[3]^2*x[5]) + x[1]*x[4]*x[5]/(216*x[2]*x[3]^2*x[6]) + x[2]*x[3]^2*x[5]/(216*x[1]*x[4]^2*x[6]) + x[2]^2*x[3]*x[6]/(216*x[1]*x[4]*x[5]) + x[2]^2*x[3]*x[5]/(216*x[1]*x[4]^2) + x[2]*x[4]/(216*x[1]*x[5]*x[6]) + x[4]^2/(216*x[2]^2*x[3]*x[6]) + x[2]*x[5]*x[6]/(216*x[1]*x[4]) + x[1]*x[2]*x[5]/(216*x[4]) + x[1]^2*x[2]/(216*x[4]) + x[1]*x[2]/(216*x[4]*x[6]) + x[1]*x[2]*x[6]/(216*x[4]*x[5]) + x[2]*x[3]^2*x[6]/(216*x[1]*x[4]^2) + x[3]*x[4]/(216*x[1]^2*x[5]) + x[3]*x[4]/(216*x[1]*x[5]^2) + x[3]*x[5]/(216*x[1]^2*x[6]) + x[1]^2/(216*x[2]) + x[4]/(216*x[1]) + x[2]*x[4]/(216*x[3]^2) + x[3]*x[6]/(216*x[1]^2) + x[1]*x[3]/(216*x[5]) + x[3]*x[5]^2/(216*x[1]*x[4]*x[6]^2) + x[1]*x[3]*x[5]/(216*x[4]*x[6]) + x[3]*x[6]^2/(216*x[1]*x[4]) + x[1]*x[4]*x[6]/(216*x[2]*x[3]^2) + x[2]*x[3]^2/(216*x[1]^2*x[4]) + x[1]*x[2]^2/(216*x[3]*x[4]) + x[1]*x[3]*x[6]/(216*x[4]) + x[4]^2/(216*x[1]*x[2]*x[5]*x[6]) + x[4]^2*x[6]/(216*x[1]*x[2]*x[5]^2) + x[4]*x[5]/(216*x[1]*x[2]*x[6]^2) + x[1]*x[2]*x[4]/(216*x[3]^2*x[5]) + x[1]*x[2]*x[5]/(216*x[3]^2*x[6]) + x[1]*x[2]*x[5]/(216*x[4]^2) + x[4]^2/(216*x[1]*x[3]*x[5]) + x[4]*x[5]/(216*x[1]*x[3]*x[6]) + x[4]*x[6]/(216*x[1]*x[3]) + x[1]^2*x[4]/(216*x[3]*x[5]) + x[1]*x[4]/(216*x[2]*x[6]) + x[4]*x[6]^2/(216*x[1]*x[2]*x[5]) + x[1]*x[4]*x[6]/(216*x[2]*x[5]) + x[5]^2/(216*x[1]*x[2]*x[6]) + x[1]*x[4]/(216*x[2]^2*x[3]) + x[3]^2/(216*x[1]*x[2]*x[5]) + x[3]^2*x[5]/(216*x[1]*x[2]*x[4]*x[6]) + x[2]*x[4]*x[6]/(216*x[1]*x[5]^2) + x[4]^2*x[6]/(216*x[2]^2*x[3]*x[5]) + x[4]*x[5]/(216*x[2]^2*x[3]) + x[3]/(216*x[2]^2) + x[2]^2/(216*x[5]) + x[2]^2*x[5]/(216*x[4]*x[6]) + x[5]*x[6]/(216*x[1]*x[2]) + x[1]*x[5]/(216*x[2]) + x[1]/(216*x[2]*x[6]) + x[1]*x[6]/(216*x[2]*x[5]) + x[1]*x[5]/(216*x[2]*x[4]) + x[4]/(216*x[1]*x[5]*x[6]) + x[4]*x[6]/(216*x[1]*x[5]^2) + x[1]*x[4]/(216*x[5]^2) + x[5]/(216*x[1]^2) + x[5]/(216*x[1]*x[6]^2) + x[6]^2/(216*x[1]*x[5]) + x[5]^2/(216*x[1]*x[4]*x[6]) + x[1]*x[5]^2/(216*x[4]*x[6]^2) + x[5]*x[6]/(216*x[1]*x[4]) + x[1]*x[6]^2/(216*x[4]) + x[1]^2/(216*x[4]) + x[4]^2/(216*x[1]*x[2]*x[3]*x[5]) + x[1]*x[4]^2/(216*x[2]*x[3]*x[5]*x[6]) + x[1]*x[4]^2*x[6]/(216*x[2]*x[3]*x[5]^2) + x[4]*x[5]/(216*x[1]*x[2]*x[3]*x[6]) + x[4]*x[6]/(216*x[1]*x[2]*x[3]) + x[1]*x[4]*x[5]/(216*x[2]*x[3]*x[6]^2) + x[2]^2*x[6]/(216*x[4]) + x[2]*x[4]/(216*x[3]*x[6]) + x[2]*x[4]*x[6]/(216*x[3]*x[5]) + x[2]*x[5]/(216*x[3]) + x[2]/(216*x[3]*x[6]) + x[2]*x[6]/(216*x[3]*x[5]) + x[2]*x[5]/(216*x[3]*x[4]) + x[2]*x[3]/(216*x[5]*x[6]) + x[2]*x[3]*x[6]/(216*x[5]^2) + x[2]*x[3]*x[5]/(216*x[4]*x[6]^2) + x[2]*x[3]*x[6]^2/(216*x[4]*x[5]) + x[2]*x[3]*x[5]^2/(216*x[4]^2*x[6]) + x[2]*x[3]*x[5]*x[6]/(216*x[4]^2) + x[2]^2/(216*x[3]*x[6]) + x[2]^2*x[6]/(216*x[3]*x[5]) + x[2]^2*x[5]/(216*x[3]*x[4]) + x[2]^2*x[3]/(216*x[4]^2) + x[2]/(216*x[6]^2) + x[2]*x[6]^2/(216*x[5]^2) + x[2]*x[5]^2/(216*x[4]^2) + x[4]^2/(216*x[2]*x[3]^2) + x[4]/(216*x[2]*x[6]^2) + x[4]*x[6]^2/(216*x[2]*x[5]^2) + x[5]^2/(216*x[2]*x[4]) + x[4]^2/(216*x[2]*x[3]*x[6]) + x[3]/(216*x[5]*x[6]) + x[3]*x[6]/(216*x[5]^2) + x[3]*x[5]/(216*x[4]*x[6]^2) + x[3]*x[6]^2/(216*x[4]*x[5]) + x[3]*x[5]^2/(216*x[4]^2*x[6]) + x[3]*x[5]*x[6]/(216*x[4]^2) + x[4]/(216*x[3]^2) + x[3]^2/(216*x[4]*x[6]) + x[3]^2*x[6]/(216*x[4]*x[5]) + x[3]^2*x[5]/(216*x[4]^2) + x[6]/(216*x[4]) + x[4]^2*x[6]/(216*x[2]*x[3]*x[5]) + x[4]*x[5]/(216*x[2]*x[3]) + x[4]/(216*x[2]*x[3]*x[6]) + x[4]*x[6]/(216*x[2]*x[3]*x[5]) + x[5]/(216*x[2]*x[3]) + x[3]*x[4]/(216*x[2]*x[5]*x[6]) + x[3]*x[4]*x[6]/(216*x[2]*x[5]^2) + x[3]*x[5]/(216*x[2]*x[6]^2) + x[3]*x[6]^2/(216*x[2]*x[5]) + x[3]*x[5]^2/(216*x[2]*x[4]*x[6]) + x[3]*x[5]*x[6]/(216*x[2]*x[4]) + x[4]^2/(216*x[2]^2*x[5]) + x[4]*x[5]/(216*x[2]^2*x[6]) + x[4]*x[6]/(216*x[2]^2) + x[1]*x[2]^2/(216*x[4]*x[6]) + x[1]*x[2]^2*x[6]/(216*x[4]*x[5]) + x[1]*x[2]^2*x[5]/(216*x[4]^2) + x[2]*x[4]/(216*x[1]*x[3]*x[5]) + x[1]*x[2]*x[4]/(216*x[3]*x[5]*x[6]) + x[1]*x[2]*x[4]*x[6]/(216*x[3]*x[5]^2) + x[2]*x[5]/(216*x[1]*x[3]*x[6]) + x[1]*x[2]*x[5]/(216*x[3]*x[6]^2) + x[2]*x[6]/(216*x[1]*x[3]) + x[1]*x[2]*x[6]^2/(216*x[3]*x[5]) + x[1]^2*x[2]/(216*x[3]*x[5]) + x[1]*x[2]*x[5]^2/(216*x[3]*x[4]*x[6]) + x[1]*x[2]*x[5]*x[6]/(216*x[3]*x[4]) + x[1]^2*x[2]*x[5]/(216*x[3]*x[4]*x[6]) + x[1]^2*x[2]*x[6]/(216*x[3]*x[4]) + x[1]*x[4]^2/(216*x[3]^2*x[5]) + x[1]*x[4]*x[5]/(216*x[3]^2*x[6]) + x[1]*x[4]*x[6]/(216*x[3]^2) + x[1]^2*x[4]/(216*x[3]^2*x[6]) + x[1]^2*x[4]*x[6]/(216*x[3]^2*x[5]) + x[1]^2*x[5]/(216*x[3]^2) + x[2]*x[3]/(216*x[1]*x[6]) + x[2]*x[3]*x[6]/(216*x[1]*x[5]) + x[2]*x[3]/(216*x[1]^2*x[5]) + x[2]*x[3]*x[5]/(216*x[1]*x[4]) + x[1]*x[4]*x[6]^2/(216*x[2]*x[3]*x[5]) + x[1]^2*x[4]/(216*x[2]*x[3]*x[5]) + x[1]*x[5]^2/(216*x[2]*x[3]*x[6]) + x[1]^2*x[5]/(216*x[2]*x[3]*x[6]) + x[1]*x[5]*x[6]/(216*x[2]*x[3]) + x[1]^2*x[6]/(216*x[2]*x[3]) + x[3]^2*x[5]/(216*x[1]*x[4]*x[6]) + x[3]^2/(216*x[1]*x[5]) + x[3]^2*x[6]/(216*x[1]*x[4]) + x[3]*x[4]*x[6]/(216*x[1]*x[2]*x[5]) + x[3]*x[4]/(216*x[1]*x[2]*x[6]) + x[3]*x[4]/(216*x[1]^2*x[2]*x[5]) + x[3]*x[5]/(216*x[1]^2*x[2]*x[6]) + x[3]*x[5]/(216*x[1]*x[2]) + x[3]/(216*x[1]*x[2]*x[6]) + x[3]*x[6]/(216*x[1]^2*x[2]) + x[1]*x[3]/(216*x[2]*x[5]) + x[3]*x[6]/(216*x[1]*x[2]*x[5]) + x[1]*x[3]*x[5]/(216*x[2]*x[4]*x[6]) + x[3]*x[5]/(216*x[1]*x[2]*x[4]) + x[4]/(216*x[1]*x[2]^2) + x[1]*x[3]*x[6]/(216*x[2]*x[4]) + x[1]*x[5]/(216*x[2]^2) + x[1]*x[4]*x[6]/(216*x[2]^2*x[5]) + x[1]*x[4]/(216*x[2]^2*x[6]) + x[1]*x[4]/(216*x[3]) + x[3]^2/(216*x[1]^2*x[2]) + x[3]^2/(216*x[1]^2*x[4]) + x[3]/216,
    x[3]^2*x[5]^2/(720*x[1]*x[2]^2*x[4]*x[6]) + x[1]*x[4]^2/(720*x[2]*x[5]^2*x[6]) + x[2]*x[3]*x[6]^2/(720*x[1]^2*x[4]*x[5]) + x[1]*x[4]*x[6]^3/(720*x[3]*x[5]^2) + x[2]*x[3]^3/(720*x[1]*x[4]^2*x[6]) + x[2]*x[5]*x[6]/(720*x[1]*x[3]*x[4]) + x[4]^2*x[6]/(720*x[1]^2*x[3]*x[5]) + x[2]^2*x[3]*x[6]/(720*x[1]^2*x[5]^2) + x[1]*x[4]^2/(720*x[2]^2*x[5]) + x[3]^2*x[5]/(720*x[4]*x[6]) + x[1]*x[2]*x[6]^2/(720*x[3]^2*x[5]) + x[2]*x[3]^2*x[5]/(720*x[1]*x[4]^2*x[6]^2) + x[1]^2*x[5]/(720*x[2]^2) + x[1]^2*x[2]*x[5]*x[6]/(720*x[3]*x[4]) + x[1]^3*x[2]*x[5]/(720*x[3]*x[4]*x[6]) + x[4]*x[5]^2/(720*x[1]*x[2]^2*x[6]^2) + x[1]*x[2]*x[4]*x[6]/(720*x[3]*x[5]) + x[1]*x[2]*x[3]/(720*x[4]*x[5]*x[6]) + x[1]*x[4]^3/(720*x[2]^2*x[3]^2*x[5]*x[6]) + x[4]^2*x[6]/(720*x[1]*x[2]*x[5]) + x[2]*x[3]^2*x[5]^2/(720*x[1]^2*x[4]^2*x[6]^2) + x[1]*x[2]*x[5]/(720*x[3]*x[6]^3) + x[2]*x[3]*x[5]*x[6]^2/(720*x[1]*x[4]^2) + x[2]*x[5]^3/(720*x[1]*x[4]^2*x[6]) + x[3]^2*x[5]/(720*x[1]^2*x[2]^2) + x[1]^2*x[2]^2*x[5]/(720*x[3]*x[4]*x[6]^2) + x[4]^2/(720*x[1]*x[2]*x[5]*x[6]^2) + x[1]*x[3]*x[4]/(720*x[2]*x[5]*x[6]) + x[4]^2*x[6]^2/(720*x[1]^2*x[2]*x[5]^2) + x[3]^2*x[5]/(720*x[1]*x[2]^2*x[6]^2) + x[3]^2*x[6]^2/(720*x[1]*x[2]^2*x[5]) + x[4]^2*x[6]^2/(720*x[1]*x[2]*x[5]^3) + x[1]*x[4]^2*x[6]/(720*x[2]*x[5]^3) + x[2]*x[3]^3/(720*x[1]^2*x[4]*x[5]) + x[1]*x[2]*x[5]/(720*x[4]^2*x[6]) + x[1]^2*x[4]*x[6]/(720*x[2]^2*x[5]) + x[1]*x[5]^2/(720*x[2]^2*x[4]) + x[1]^2*x[2]*x[5]^2/(720*x[3]*x[4]^2*x[6]) + x[3]*x[5]^3/(720*x[1]*x[4]^2*x[6]^2) + x[1]*x[2]*x[4]*x[6]/(720*x[5]^3) + x[3]^2*x[5]^2/(720*x[4]^3) + x[2]^2*x[3]*x[5]^2/(720*x[1]*x[4]^3) + x[1]^2*x[2]/(720*x[5]^2) + x[2]*x[4]*x[5]/(720*x[1]*x[3]^2*x[6]) + x[1]^3*x[2]*x[6]/(720*x[3]*x[4]) + x[2]*x[3]*x[5]*x[6]/(720*x[1]^2*x[4]) + x[2]*x[5]/(720*x[1]) + x[3]*x[5]/(720*x[1]^2*x[2]*x[6]^2) + x[3]/(720*x[2]^2*x[6]) + x[2]^2*x[3]^2*x[5]/(720*x[4]^3*x[6]) + x[3]*x[4]^2/(720*x[2]^2*x[5]^2) + x[3]^2/(720*x[4]*x[6]^2) + x[1]^2*x[6]^2/(720*x[2]*x[3]*x[5]) + x[4]*x[5]/(720*x[1]*x[3]^2*x[6]) + x[3]*x[4]^2*x[6]/(720*x[1]^2*x[2]*x[5]^2) + x[3]*x[5]*x[6]^2/(720*x[1]*x[4]^2) + x[3]^2*x[4]*x[6]/(720*x[1]^2*x[2]^2*x[5]) + x[1]*x[5]*x[6]^2/(720*x[2]*x[4]) + x[1]^2*x[5]^2/(720*x[2]*x[4]*x[6]^2) + x[5]^2*x[6]/(720*x[1]*x[2]*x[4]) + x[1]*x[5]^3/(720*x[2]*x[4]*x[6]^2) + x[5]^3/(720*x[1]*x[2]*x[4]*x[6]) + x[1]*x[3]^2*x[5]/(720*x[2]*x[4]^2) + x[3]^2*x[5]*x[6]/(720*x[1]*x[2]*x[4]^2) + x[3]^2*x[5]^2/(720*x[1]*x[2]*x[4]^2*x[6]) + x[1]*x[3]^2*x[6]/(720*x[2]*x[4]*x[5]) + x[3]^2*x[6]^2/(720*x[1]*x[2]*x[4]*x[5]) + x[1]*x[3]^2/(720*x[2]*x[4]*x[6]) + x[3]^2*x[6]^2/(720*x[1]^2*x[2]*x[4]) + x[3]^2*x[5]/(720*x[1]*x[2]*x[4]*x[6]^2) + x[3]^2*x[5]*x[6]/(720*x[1]*x[2]*x[4]) + x[3]^2*x[5]^2/(720*x[1]^2*x[2]*x[4]*x[6]^2) + x[3]^2*x[5]^2/(720*x[1]*x[2]*x[4]*x[6]) + x[3]^2*x[6]/(720*x[1]*x[2]*x[5]^2) + x[3]^2/(720*x[1]*x[2]*x[5]*x[6]) + x[3]^2*x[6]^2/(720*x[1]*x[2]*x[5]) + x[3]^2*x[6]/(720*x[1]^3*x[2]) + x[3]^2*x[5]/(720*x[1]*x[2]*x[6]^2) + x[3]^2*x[5]/(720*x[1]^3*x[2]*x[6]) + x[3]^2*x[4]/(720*x[1]^2*x[2]*x[5]^2) + x[3]^2*x[4]*x[6]/(720*x[1]*x[2]*x[5]^2) + x[3]^2*x[4]/(720*x[1]*x[2]*x[5]*x[6]) + x[3]^2*x[4]/(720*x[1]^3*x[2]*x[5]) + x[3]^3*x[6]/(720*x[1]^2*x[4]^2) + x[3]^3*x[5]/(720*x[1]^2*x[4]^2*x[6]) + x[3]^3*x[5]/(720*x[1]*x[4]^2) + x[3]^3/(720*x[1]^2*x[4]*x[5]) + x[3]^3*x[6]/(720*x[1]*x[4]*x[5]) + x[3]^3/(720*x[1]*x[4]*x[6]) + x[1]*x[2]^3*x[6]/(720*x[3]*x[4]*x[5]) + x[1]*x[2]^3/(720*x[3]*x[4]*x[6]) + x[1]*x[4]*x[6]/(720*x[2]^3) + x[1]*x[4]*x[5]/(720*x[2]^3*x[6]) + x[4]*x[5]/(720*x[1]*x[2]^3) + x[1]*x[4]^2/(720*x[2]^3*x[5]) + x[4]^2*x[6]/(720*x[1]*x[2]^3*x[5]) + x[4]^2/(720*x[1]*x[2]^3*x[6]) + x[1]*x[3]*x[5]*x[6]/(720*x[2]^2*x[4]) + x[1]*x[3]*x[5]^2/(720*x[2]^2*x[4]*x[6]) + x[3]*x[5]^2/(720*x[1]*x[2]^2*x[4]) + x[1]*x[3]*x[6]^2/(720*x[2]^2*x[5]) + x[1]*x[3]*x[5]/(720*x[2]^2*x[6]^2) + x[3]*x[5]*x[6]/(720*x[1]^2*x[2]^2) + x[3]*x[5]^2/(720*x[1]^2*x[2]^2*x[6]) + x[1]*x[3]*x[4]*x[6]/(720*x[2]^2*x[5]^2) + x[3]*x[4]*x[6]^2/(720*x[1]*x[2]^2*x[5]^2) + x[1]*x[3]*x[4]/(720*x[2]^2*x[5]*x[6]) + x[3]*x[4]*x[6]^2/(720*x[1]^2*x[2]^2*x[5]) + x[3]*x[4]/(720*x[1]*x[2]^2*x[6]^2) + x[3]*x[4]*x[6]/(720*x[1]*x[2]^2) + x[3]*x[4]*x[5]/(720*x[1]^2*x[2]^2*x[6]^2) + x[3]*x[4]*x[5]/(720*x[1]*x[2]^2*x[6]) + x[3]*x[4]^2*x[6]/(720*x[1]^2*x[2]^2*x[5]^2) + x[3]*x[4]^2/(720*x[1]^2*x[2]^2*x[5]*x[6]) + x[3]*x[4]^2/(720*x[1]*x[2]^2*x[5]) + x[2]^2*x[6]^2/(720*x[1]*x[4]) + x[1]*x[2]^2*x[5]/(720*x[4]*x[6]) + x[2]^2*x[5]/(720*x[1]^2*x[4]*x[6]) + x[2]^2*x[5]^2/(720*x[1]*x[4]*x[6]^2) + x[1]*x[2]^2/(720*x[5]) + x[2]^2/(720*x[1]^2*x[5]) + x[2]^2*x[4]/(720*x[1]*x[5]^2) + x[2]^3*x[3]*x[6]/(720*x[1]*x[4]^2) + x[2]^3*x[3]*x[5]/(720*x[1]*x[4]^2*x[6]) + x[2]^3*x[3]/(720*x[1]*x[4]*x[5]) + x[1]^2*x[2]*x[5]/(720*x[3]^3) + x[1]^2*x[2]*x[4]*x[6]/(720*x[3]^3*x[5]) + x[1]^2*x[2]*x[4]/(720*x[3]^3*x[6]) + x[1]*x[2]*x[4]*x[6]/(720*x[3]^3) + x[1]*x[2]*x[4]*x[5]/(720*x[3]^3*x[6]) + x[1]*x[2]*x[4]^2/(720*x[3]^3*x[5]) + x[1]^2*x[2]^2*x[6]/(720*x[3]^2*x[4]) + x[1]^2*x[2]^2*x[5]/(720*x[3]^2*x[4]*x[6]) + x[1]*x[2]^2*x[5]*x[6]/(720*x[3]^2*x[4]) + x[1]*x[2]^2*x[5]^2/(720*x[3]^2*x[4]*x[6]) + x[1]^2*x[2]^2/(720*x[3]^2*x[5]) + x[1]*x[2]^2*x[6]^2/(720*x[3]^2*x[5]) + x[1]*x[2]^2*x[5]/(720*x[3]^2*x[6]^2) + x[1]*x[2]^2*x[4]*x[6]/(720*x[3]^2*x[5]^2) + x[1]*x[2]^2*x[4]/(720*x[3]^2*x[5]*x[6]) + x[1]*x[2]^3*x[5]/(720*x[3]*x[4]^2) + x[2]*x[6]^2/(720*x[3]^2) + x[2]*x[5]^2/(720*x[3]^2*x[6]^2) + x[2]*x[4]^2/(720*x[3]^2*x[5]^2) + x[2]^2*x[5]^2/(720*x[3]*x[4]^2) + x[2]^2*x[6]^2/(720*x[3]*x[5]^2) + x[2]^2/(720*x[3]*x[6]^2) + x[2]^2*x[6]/(720*x[3]) + x[2]^2*x[5]/(720*x[3]*x[6]) + x[2]^2*x[4]/(720*x[3]*x[5]) + x[2]^3/(720*x[4]^2) + x[2]^3/(720*x[4]) + x[2]*x[3]^2*x[5]^2/(720*x[4]^3) + x[2]*x[3]^2*x[6]^2/(720*x[4]*x[5]^2) + x[2]*x[3]^2/(720*x[4]*x[6]^2) + x[2]*x[3]*x[5]^2/(720*x[1]*x[4]*x[6]^3) + x[3]*x[6]/(720*x[1]*x[2]*x[4]) + x[3]*x[4]^2/(720*x[1]^2*x[2]*x[5]*x[6]) + x[1]*x[5]^2*x[6]/(720*x[2]*x[3]*x[4]) + x[1]^2*x[3]/(720*x[4]*x[5]) + x[1]^2*x[3]*x[5]/(720*x[4]^2*x[6]) + x[1]^2*x[3]*x[6]/(720*x[4]^2) + x[3]^2*x[4]/(720*x[1]*x[2]^2*x[5]*x[6]) + x[2]*x[4]^2/(720*x[1]*x[3]*x[5]*x[6]) + x[2]^2*x[3]/(720*x[1]*x[4]*x[6]^2) + x[2]*x[3]^2*x[5]*x[6]/(720*x[1]*x[4]^2) + x[1]*x[2]*x[6]^3/(720*x[3]*x[5]^2) + x[3]^2*x[4]/(720*x[1]^2*x[2]^2*x[6]) + x[3]*x[6]^2/(720*x[1]^2*x[2]*x[5]) + x[1]*x[2]^2*x[3]*x[6]^2/(720*x[4]^2*x[5]) + x[3]*x[5]/(720*x[1]^3*x[2]) + x[2]^2*x[3]*x[5]/(720*x[1]^2*x[4]*x[6]^2) + x[1]^2*x[4]*x[5]/(720*x[3]^3) + x[3]^2*x[6]/(720*x[1]^2*x[4]*x[5]) + x[4]^2/(720*x[1]*x[2]*x[6]) + x[1]*x[4]*x[6]/(720*x[3]^3) + x[1]*x[3]*x[6]^2/(720*x[2]*x[4]*x[5]) + x[2]^2*x[6]^2/(720*x[1]*x[3]*x[5]) + x[2]*x[3]^2*x[5]^2/(720*x[1]*x[4]^2*x[6]) + x[4]*x[5]/(720*x[1]^2*x[3]) + x[2]^3*x[5]/(720*x[1]*x[4]^2) + x[1]*x[2]/(720*x[4]*x[5]) + x[1]*x[4]/(720*x[2]^2*x[6]^2) + x[4]*x[5]^2/(720*x[2]*x[3]*x[6]^3) + x[1]*x[2]*x[4]*x[6]/(720*x[3]^2*x[5]^2) + x[2]*x[3]^2/(720*x[1]*x[4]*x[5]*x[6]) + x[1]^2*x[2]*x[5]^2/(720*x[4]^2*x[6]^2) + x[4]^3/(720*x[1]*x[2]^2*x[5]^2) + x[2]*x[4]*x[6]^2/(720*x[1]*x[3]*x[5]) + x[2]*x[4]*x[6]/(720*x[1]^2*x[3]*x[5]) + x[2]*x[5]/(720*x[1]*x[3]*x[6]^2) + x[1]^2*x[2]*x[5]/(720*x[3]*x[6]^2) + x[2]*x[3]*x[5]^3/(720*x[4]^3*x[6]) + x[2]*x[3]*x[5]^2*x[6]/(720*x[4]^3) + x[1]*x[2]^2*x[3]*x[5]*x[6]/(720*x[4]^3) + x[2]*x[5]^2/(720*x[1]*x[3]*x[4]*x[6]) + x[3]*x[4]*x[6]^2/(720*x[1]^2*x[2]*x[5]) + x[1]^2*x[4]*x[5]/(720*x[2]^2*x[3]^2*x[6]) + x[1]^2*x[4]/(720*x[2]^2*x[6]) + x[2]*x[3]/(720*x[5]*x[6]^2) + x[2]*x[3]*x[6]^2/(720*x[5]^3) + x[4]^2/(720*x[3]*x[5]^2*x[6]) + x[1]*x[2]*x[5]/(720*x[3]) + x[4]^2*x[6]/(720*x[3]*x[5]^3) + x[1]*x[2]*x[3]^2*x[6]/(720*x[4]^2*x[5]) + x[4]^2*x[6]^2/(720*x[3]*x[5]^2) + x[3]^2*x[5]/(720*x[1]^2*x[4]^2) + x[1]*x[2]^2*x[4]/(720*x[3]*x[5]^2) + x[2]*x[3]*x[5]/(720*x[4]) + x[1]^2*x[2]*x[5]^2/(720*x[3]*x[4]*x[6]) + x[1]*x[2]*x[4]*x[6]^2/(720*x[3]*x[5]^3) + x[1]^2*x[5]/(720*x[2]*x[3]*x[6]^2) + x[3]^2/(720*x[5]) + x[1]*x[2]*x[3]*x[6]^2/(720*x[4]*x[5]) + x[3]^2/(720*x[2]^2*x[5]) + x[2]*x[5]^2/(720*x[1]*x[3]*x[6]) + x[2]^2*x[3]*x[6]^2/(720*x[1]^2*x[4]*x[5]) + x[1]*x[2]^2*x[3]/(720*x[4]*x[5]*x[6]) + x[1]^2*x[2]^2*x[6]^2/(720*x[3]*x[4]*x[5]) + x[4]^2*x[6]/(720*x[2]^3*x[3]) + x[1]*x[4]*x[5]/(720*x[2]^2*x[6]) + x[1]^3*x[4]/(720*x[3]^3) + x[2]^2*x[4]/(720*x[1]*x[3]*x[5]*x[6]) + x[2]^2*x[3]/(720*x[1]*x[5]) + x[1]^2*x[2]*x[4]/(720*x[3]*x[5]*x[6]) + x[3]*x[4]/(720*x[2]^3*x[6]) + x[3]*x[5]^2/(720*x[1]^2*x[2]*x[6]) + x[2]*x[3]*x[6]^3/(720*x[4]*x[5]^2) + x[1]*x[2]*x[6]/(720*x[4]^2) + x[1]*x[4]*x[6]^2/(720*x[2]^2*x[5]^2) + x[1]*x[4]^2*x[6]^2/(720*x[3]*x[5]^3) + x[1]^2*x[2]*x[6]/(720*x[3]*x[5]^2) + x[1]*x[2]^2*x[6]^2/(720*x[3]*x[4]) + x[2]*x[4]*x[6]^2/(720*x[1]^2*x[5]^2) + x[2]*x[3]^2*x[6]/(720*x[1]*x[5]^2) + x[1]^2*x[2]*x[6]^2/(720*x[4]^2) + x[3]^2*x[4]*x[6]/(720*x[1]*x[2]^2*x[5]^2) + x[4]^2/(720*x[1]^2*x[2]*x[6]^2) + x[4]^3/(720*x[2]*x[3]*x[5]^2*x[6]) + x[1]^2*x[4]*x[5]/(720*x[3]^2*x[6]) + x[1]*x[4]^2/(720*x[3]*x[5]*x[6]^2) + x[1]*x[2]^2*x[6]/(720*x[3]*x[4]*x[5]) + x[2]*x[4]*x[5]/(720*x[1]*x[3]*x[6]^2) + x[1]^2*x[2]*x[3]/(720*x[4]*x[5]) + x[1]^2*x[2]*x[5]*x[6]/(720*x[3]*x[4]^2) + x[1]*x[2]*x[3]*x[5]*x[6]/(720*x[4]^2) + x[1]*x[2]^3*x[6]/(720*x[4]^2) + x[3]*x[5]/(720*x[1]*x[2]*x[4]*x[6]) + x[2]*x[3]^3*x[6]/(720*x[1]^2*x[4]^2) + x[4]^2/(720*x[3]^3) + x[1]^2*x[4]^2/(720*x[3]^2*x[5]) + x[1]*x[2]*x[5]^2/(720*x[3]^2*x[6]) + x[2]*x[4]/(720*x[1]^2*x[3]*x[6]) + x[1]^3*x[6]/(720*x[2]*x[3]) + x[4]*x[6]/(720*x[1]*x[3]^2) + x[1]*x[2]*x[4]/(720*x[5]^2*x[6]) + x[2]*x[3]^2*x[6]^2/(720*x[1]*x[4]^2*x[5]) + x[1]*x[2]*x[4]/(720*x[3]*x[6]) + x[2]*x[5]/(720*x[1]*x[6]^3) + x[2]*x[3]^2*x[6]/(720*x[1]^3*x[4]) + x[2]^2*x[3]/(720*x[1]^2*x[5]*x[6]) + x[1]*x[2]*x[3]/(720*x[5]*x[6]) + x[2]*x[3]*x[5]/(720*x[1]*x[4]^2*x[6]) + x[2]^2*x[3]^2/(720*x[4]^2*x[5]) + x[4]^3/(720*x[2]^3*x[3]*x[5]) + x[3]*x[5]/(720*x[2]^3) + x[1]*x[3]^2/(720*x[4]*x[6]) + x[2]*x[6]^3/(720*x[1]*x[5]^2) + x[1]^2*x[4]^2/(720*x[3]^3*x[6]) + x[1]*x[2]*x[5]^3/(720*x[3]*x[4]^2*x[6]) + x[2]*x[3]^2*x[6]^2/(720*x[1]^2*x[4]^2) + x[1]*x[4]^3*x[6]/(720*x[2]^2*x[3]^2*x[5]^2) + x[3]*x[6]^2/(720*x[2]^2) + x[1]*x[4]^2/(720*x[3]^3*x[5]) + x[1]*x[2]*x[5]*x[6]/(720*x[3]^2*x[4]) + x[1]*x[2]*x[5]*x[6]/(720*x[3]^2) + x[1]*x[2]*x[4]/(720*x[3]*x[5]*x[6]^2) + x[3]^2*x[6]^2/(720*x[2]*x[5]^2) + x[3]^2*x[5]/(720*x[2]^2*x[4]*x[6]) + x[3]^2/(720*x[2]*x[6]^2) + x[5]^2/(720*x[2]^2*x[3]) + x[4]^2*x[6]^2/(720*x[2]^2*x[3]*x[5]^2) + x[4]^2/(720*x[2]^2*x[3]*x[6]^2) + x[4]^2*x[6]/(720*x[2]^2*x[3]) + x[4]^2*x[5]/(720*x[2]^2*x[3]*x[6]) + x[4]^3/(720*x[2]^2*x[3]*x[5]) + x[2]*x[6]/(720*x[3]*x[4]) + x[2]*x[5]/(720*x[3]*x[4]*x[6]) + x[2]*x[5]*x[6]^2/(720*x[3]*x[4]) + x[2]*x[5]^3/(720*x[3]*x[4]*x[6]^2) + x[2]/(720*x[3]*x[5]) + x[2]*x[6]^3/(720*x[3]*x[5]) + x[2]*x[5]^2/(720*x[3]*x[6]^3) + x[2]*x[4]^2*x[6]/(720*x[3]*x[5]^3) + x[2]*x[4]^2/(720*x[3]*x[5]^2*x[6]) + x[2]^3*x[3]*x[5]/(720*x[4]^3) + x[2]^3*x[3]*x[6]/(720*x[4]^2*x[5]) + x[2]^3*x[3]/(720*x[4]^2*x[6]) + x[2]^2*x[5]/(720*x[3]^2) + x[2]^2*x[4]*x[6]/(720*x[3]^2*x[5]) + x[2]^2*x[4]/(720*x[3]^2*x[6]) + x[2]^3*x[6]/(720*x[3]*x[4]) + x[2]^3*x[5]/(720*x[3]*x[4]*x[6]) + x[2]^3/(720*x[3]*x[5]) + x[4]/(720*x[2]^3) + x[3]^3/(720*x[1]^3*x[4]) + x[1]*x[5]/(720*x[2]^2*x[3]) + x[1]^2*x[5]*x[6]/(720*x[2]^2*x[3]) + x[1]^2*x[5]^2/(720*x[2]^2*x[3]*x[6]) + x[1]*x[4]*x[6]/(720*x[2]^2*x[3]*x[5]) + x[1]^2*x[4]*x[6]^2/(720*x[2]^2*x[3]*x[5]) + x[1]*x[4]/(720*x[2]^2*x[3]*x[6]) + x[1]*x[4]*x[6]^2/(720*x[2]^2*x[3]) + x[1]^2*x[4]*x[5]/(720*x[2]^2*x[3]*x[6]^2) + x[4]*x[5]*x[6]/(720*x[1]*x[2]^2*x[3]) + x[1]*x[4]*x[5]^2/(720*x[2]^2*x[3]*x[6]^2) + x[4]*x[5]^2/(720*x[1]*x[2]^2*x[3]*x[6]) + x[1]^2*x[4]^2*x[6]/(720*x[2]^2*x[3]*x[5]^2) + x[1]^2*x[4]^2/(720*x[2]^2*x[3]*x[5]*x[6]) + x[4]^2*x[6]^2/(720*x[1]*x[2]^2*x[3]*x[5]) + x[4]^2*x[5]/(720*x[1]*x[2]^2*x[3]*x[6]^2) + x[1]*x[4]^3/(720*x[2]^2*x[3]*x[5]^2) + x[4]^3*x[6]/(720*x[1]*x[2]^2*x[3]*x[5]^2) + x[4]^3/(720*x[1]*x[2]^2*x[3]*x[5]*x[6]) + x[1]*x[6]/(720*x[2]*x[4]) + x[1]^2*x[6]^2/(720*x[2]*x[4]) + x[1]*x[5]/(720*x[2]*x[4]*x[6]) + x[4]^2/(720*x[1]*x[3]^2*x[5]) + x[1]*x[2]*x[3]^2/(720*x[4]^2*x[6]) + x[2]*x[4]*x[6]^2/(720*x[1]*x[5]^3) + x[2]*x[3]*x[5]/(720*x[4]*x[6]^3) + x[2]*x[3]^2*x[5]/(720*x[1]^3*x[4]*x[6]) + x[2]*x[4]*x[6]/(720*x[1]*x[3]*x[5]^2) + x[1]*x[2]*x[3]*x[6]/(720*x[4]*x[5]^2) + x[1]^2*x[2]*x[4]*x[6]/(720*x[3]*x[5]^2) + x[4]^2/(720*x[1]^2*x[2]^2*x[5]) + x[2]*x[4]/(720*x[1]*x[6]) + x[2]*x[3]^2/(720*x[1]*x[5]*x[6]) + x[2]*x[4]/(720*x[1]^2*x[6]^2) + x[1]*x[3]*x[5]*x[6]/(720*x[2]*x[4]) + x[3]*x[5]^2/(720*x[2]^2*x[6]^2) + x[2]*x[4]*x[6]/(720*x[1]*x[5]) + x[2]*x[3]^3*x[5]/(720*x[1]*x[4]^3) + x[2]*x[4]*x[6]/(720*x[1]*x[3]^2) + x[1]*x[3]*x[5]^2/(720*x[2]*x[4]*x[6]) + x[2]*x[3]*x[5]/(720*x[1]^3*x[4]) + x[2]*x[6]^2/(720*x[1]*x[3]*x[5]) + x[2]*x[4]/(720*x[1]*x[3]*x[5]*x[6]) + x[2]*x[3]^2*x[6]/(720*x[1]*x[4]*x[5]^2) + x[4]^2/(720*x[1]^2*x[3]*x[6]) + x[1]*x[2]^2*x[3]*x[5]/(720*x[4]^2*x[6]^2) + x[2]*x[3]^3*x[6]/(720*x[1]*x[4]^2*x[5]) + x[2]^2*x[3]*x[5]*x[6]/(720*x[1]^2*x[4]^2) + x[1]^3*x[5]/(720*x[2]*x[3]^2) + x[1]^2*x[2]*x[3]*x[5]/(720*x[4]^2*x[6]) + x[4]*x[6]^2/(720*x[1]*x[2]^2) + x[2]^2*x[3]*x[6]/(720*x[1]*x[4]) + x[2]*x[5]^2*x[6]/(720*x[1]*x[4]^2) + x[3]*x[5]*x[6]/(720*x[1]^2*x[2]*x[4]) + x[2]*x[3]^2*x[5]/(720*x[1]*x[4]*x[6]^2) + x[4]^3*x[6]/(720*x[2]*x[3]*x[5]^3) + x[2]*x[3]/(720*x[1]^2*x[5]*x[6]) + x[3]^2*x[6]/(720*x[2]^2*x[4]) + x[1]*x[2]*x[6]^3/(720*x[4]*x[5]) + x[3]*x[5]^3/(720*x[1]*x[2]*x[4]*x[6]^2) + x[2]*x[4]^2*x[6]/(720*x[1]*x[3]*x[5]^2) + x[1]*x[2]*x[5]^2*x[6]/(720*x[3]*x[4]^2) + x[3]*x[5]^2/(720*x[1]*x[2]*x[6]^3) + x[3]*x[4]^2*x[6]/(720*x[1]*x[2]*x[5]^3) + x[1]*x[3]*x[6]/(720*x[2]*x[5]^2) + x[5]/(720*x[1]*x[2]^2) + x[1]^2*x[2]*x[6]^2/(720*x[3]*x[5]) + x[1]*x[2]^2*x[5]^2/(720*x[4]^3) + x[1]^2*x[2]^2*x[5]/(720*x[4]^2) + x[2]^2*x[5]/(720*x[1]*x[4]^2) + x[1]*x[2]^2*x[6]^2/(720*x[4]*x[5]^2) + x[1]^2*x[2]^2*x[6]/(720*x[4]*x[5]) + x[2]^2*x[6]/(720*x[1]*x[4]*x[5]) + x[1]*x[2]^2/(720*x[4]*x[6]^2) + x[1]^2*x[2]^2/(720*x[4]*x[6]) + x[2]^2/(720*x[1]*x[4]*x[6]) + x[1]*x[2]^2*x[6]/(720*x[4]) + x[2]^2*x[6]/(720*x[1]^2*x[4]) + x[1]*x[5]*x[6]/(720*x[2]*x[3]^2) + x[1]*x[5]^2/(720*x[2]*x[3]^2*x[6]) + x[1]^2*x[5]^2/(720*x[2]*x[3]^2) + x[1]^3*x[4]*x[6]/(720*x[2]*x[3]^2*x[5]) + x[1]*x[4]*x[6]^2/(720*x[2]*x[3]^2*x[5]) + x[1]^3*x[4]/(720*x[2]*x[3]^2*x[6]) + x[1]*x[4]*x[5]/(720*x[2]*x[3]^2*x[6]^2) + x[1]*x[4]*x[5]*x[6]/(720*x[2]*x[3]^2) + x[1]*x[4]*x[5]^2/(720*x[2]*x[3]^2*x[6]) + x[1]*x[4]^2*x[6]/(720*x[2]*x[3]^2*x[5]^2) + x[1]^2*x[4]^2*x[6]^2/(720*x[2]*x[3]^2*x[5]^2) + x[1]*x[4]^2/(720*x[2]*x[3]^2*x[5]*x[6]) + x[1]*x[4]^2*x[6]^2/(720*x[2]*x[3]^2*x[5]) + x[1]^2*x[4]^2/(720*x[2]*x[3]^2*x[6]^2) + x[4]^2*x[6]/(720*x[1]*x[2]*x[3]^2) + x[1]*x[4]^2*x[5]/(720*x[2]*x[3]^2*x[6]^2) + x[4]^2*x[5]/(720*x[1]*x[2]*x[3]^2*x[6]) + x[1]*x[4]^3*x[6]/(720*x[2]*x[3]^2*x[5]^2) + x[1]*x[4]^3/(720*x[2]*x[3]^2*x[5]*x[6]) + x[4]^3/(720*x[1]*x[2]*x[3]^2*x[5]) + x[1]^3*x[6]/(720*x[3]*x[4]) + x[1]*x[6]^2/(720*x[3]*x[4]) + x[1]^3*x[5]/(720*x[3]*x[4]*x[6]) + x[1]*x[5]^2/(720*x[3]*x[4]*x[6]^2) + x[1]*x[5]^2*x[6]/(720*x[3]*x[4]) + x[1]*x[5]^3/(720*x[3]*x[4]*x[6]) + x[1]^3/(720*x[3]*x[5]) + x[1]*x[4]/(720*x[3]*x[5]^2) + x[3]*x[5]^2*x[6]/(720*x[2]*x[4]^2) + x[3]*x[5]^3/(720*x[2]*x[4]^2*x[6]) + x[3]*x[6]^3/(720*x[2]*x[5]^2) + x[3]*x[5]/(720*x[2]*x[6]^3) + x[3]*x[5]/(720*x[2]) + x[3]*x[4]*x[6]^2/(720*x[2]*x[5]^3) + x[3]*x[4]/(720*x[2]*x[5]*x[6]^2) + x[3]*x[4]*x[6]/(720*x[2]*x[5]) + x[3]*x[4]/(720*x[2]*x[6]) + x[4]^2*x[5]/(720*x[2]^2*x[3]^2) + x[4]^3*x[6]/(720*x[2]^2*x[3]^2*x[5]) + x[4]^3/(720*x[2]^2*x[3]^2*x[6]) + x[6]/(720*x[2]*x[3]) + x[5]/(720*x[2]*x[3]*x[6]) + x[5]*x[6]^2/(720*x[2]*x[3]) + x[5]^3/(720*x[2]*x[3]*x[6]^2) + x[4]/(720*x[2]*x[3]*x[5]) + x[4]*x[6]^3/(720*x[2]*x[3]*x[5]) + x[2]*x[3]/(720*x[1]^3*x[6]) + x[2]*x[3]*x[5]/(720*x[1]^2*x[6]^2) + x[2]*x[3]*x[4]*x[6]/(720*x[1]*x[5]^3) + x[2]*x[3]*x[4]/(720*x[1]*x[5]^2*x[6]) + x[2]*x[3]*x[4]*x[6]/(720*x[1]^2*x[5]^2) + x[2]*x[3]*x[4]/(720*x[1]^2*x[5]*x[6]) + x[2]^2*x[3]^2*x[5]*x[6]/(720*x[1]*x[4]^3) + x[2]^2*x[3]^2*x[6]^2/(720*x[1]*x[4]^2*x[5]) + x[2]^2*x[3]^2*x[5]/(720*x[1]*x[4]^2*x[6]^2) + x[2]^2*x[3]^2*x[5]/(720*x[1]^2*x[4]^2) + x[2]^2*x[3]^2*x[6]/(720*x[1]*x[4]*x[5]^2) + x[2]^2*x[3]^2/(720*x[1]*x[4]*x[5]*x[6]) + x[2]^2*x[3]^2*x[6]/(720*x[1]^2*x[4]*x[5]) + x[2]^2*x[3]^2/(720*x[1]^2*x[4]*x[6]) + x[1]^2*x[4]*x[5]/(720*x[2]*x[3]^3) + x[1]^2*x[4]^2*x[6]/(720*x[2]*x[3]^3*x[5]) + x[1]^2*x[4]^2/(720*x[2]*x[3]^3*x[6]) + x[1]*x[4]^2*x[6]/(720*x[2]*x[3]^3) + x[1]*x[4]^2*x[5]/(720*x[2]*x[3]^3*x[6]) + x[1]*x[4]^3/(720*x[2]*x[3]^3*x[5]) + x[1]^2*x[5]^2/(720*x[3]^2*x[4]) + x[1]^3*x[5]/(720*x[3]^2) + x[1]^2*x[4]*x[6]^2/(720*x[3]^2*x[5]^2) + x[1]^3*x[4]*x[6]/(720*x[3]^2*x[5]) + x[1]^2*x[4]/(720*x[3]^2*x[6]^2) + x[1]^3*x[4]/(720*x[3]^2*x[6]) + x[1]^2*x[4]*x[6]/(720*x[3]^2) + x[1]/(720*x[2]*x[5]) + x[1]*x[6]^3/(720*x[2]*x[5]) + x[1]*x[5]^2/(720*x[2]*x[6]^3) + x[5]^2/(720*x[1]^2*x[2]) + x[1]^2*x[4]/(720*x[2]*x[5]^2) + x[4]*x[6]^3/(720*x[1]*x[2]*x[5]^2) + x[4]*x[5]/(720*x[1]*x[2]*x[6]^3) + x[4]*x[5]/(720*x[1]*x[2]) + x[2]*x[3]*x[6]^3/(720*x[1]*x[4]*x[5]) + x[2]*x[3]*x[5]^2/(720*x[1]^2*x[4]^2*x[6]) + x[3]^2*x[6]/(720*x[4]) + x[1]*x[2]*x[5]*x[6]^2/(720*x[4]^2) + x[1]^3*x[2]/(720*x[3]^2*x[6]) + x[4]*x[6]/(720*x[1]^2*x[2]^2) + x[2]^2*x[3]*x[5]^2/(720*x[1]^2*x[4]^2*x[6]) + x[1]*x[4]*x[5]/(720*x[3]^3*x[6]) + x[3]*x[4]/(720*x[1]^2*x[2]*x[5]*x[6]) + x[1]*x[2]*x[3]*x[5]^2/(720*x[4]^2*x[6]) + x[4]^2*x[5]/(720*x[2]^3*x[3]*x[6]) + x[1]^2*x[2]*x[4]*x[6]^2/(720*x[3]^2*x[5]^2) + x[1]*x[4]^2*x[5]/(720*x[2]^2*x[3]^2*x[6]^2) + x[1]^2*x[2]*x[6]^2/(720*x[3]*x[4]*x[5]) + x[2]^2*x[3]*x[6]^2/(720*x[1]*x[4]*x[5]^2) + x[1]*x[2]*x[3]*x[5]/(720*x[4]^2*x[6]^2) + x[1]^2*x[2]*x[5]^2/(720*x[3]^2*x[4]) + x[1]^2*x[5]^2/(720*x[2]*x[3]*x[4]*x[6]) + x[1]^2*x[2]*x[4]/(720*x[3]^2*x[6]^2) + x[4]*x[5]/(720*x[1]^2*x[2]^2*x[6]) + x[3]*x[4]*x[6]/(720*x[2]^3*x[5]) + x[2]*x[3]*x[5]*x[6]/(720*x[1]^2*x[4]^2) + x[1]^3*x[2]/(720*x[3]*x[5]) + x[1]^2*x[2]/(720*x[3]*x[5]*x[6]) + x[2]^2*x[4]*x[6]/(720*x[1]*x[3]*x[5]^2) + x[1]*x[4]*x[5]/(720*x[3]*x[6]^3) + x[3]*x[5]^2/(720*x[1]^2*x[2]*x[4]*x[6]) + x[1]*x[2]*x[4]^2/(720*x[3]^2*x[5]*x[6]) + x[4]*x[6]^2/(720*x[2]*x[3]^2) + x[4]*x[5]^2/(720*x[2]*x[3]^2*x[6]^2) + x[4]^3/(720*x[2]*x[3]^2*x[5]^2) + x[2]^2*x[3]*x[5]/(720*x[4]^3) + x[2]^2*x[3]*x[6]/(720*x[4]^2*x[5]) + x[2]^2*x[3]/(720*x[4]^2*x[6]) + x[2]^2*x[3]*x[6]^2/(720*x[4]^2) + x[2]^2*x[3]*x[5]^2/(720*x[4]^2*x[6]^2) + x[2]^2*x[3]/(720*x[5]^2) + x[3]*x[4]*x[6]/(720*x[1]*x[2]^3) + x[3]*x[4]*x[5]/(720*x[1]*x[2]^3*x[6]) + x[3]*x[4]^2/(720*x[1]*x[2]^3*x[5]) + x[3]^2*x[5]*x[6]/(720*x[1]*x[2]^2*x[4]) + x[1]*x[2]^2*x[3]*x[6]/(720*x[4]*x[5]^2) + x[1]*x[4]*x[6]/(720*x[2]^2) + x[1]*x[2]^2*x[3]*x[5]^2/(720*x[4]^3*x[6]) + x[2]*x[3]^2/(720*x[1]^3*x[5]) + x[3]*x[4]^2/(720*x[1]*x[2]*x[5]^2*x[6]) + x[1]*x[3]^2*x[5]/(720*x[4]^2) + x[2]^2*x[3]*x[5]/(720*x[1]*x[4]*x[6]) + x[4]^2/(720*x[2]^3) + x[1]*x[2]^3/(720*x[4]*x[5]) + x[2]*x[5]/(720*x[1]^2*x[3]) + x[2]*x[5]*x[6]/(720*x[1]*x[3]) + x[2]*x[3]*x[5]^3/(720*x[1]*x[4]^2*x[6]^2) + x[4]/(720*x[1]*x[2]^2*x[6]) + x[2]*x[4]/(720*x[1]*x[5]*x[6]^2) + x[4]^2/(720*x[3]*x[6]^2) + x[1]*x[4]^2/(720*x[2]^3*x[3]*x[6]) + x[3]^2*x[6]^2/(720*x[4]*x[5]^2) + x[1]*x[2]*x[5]/(720*x[3]^2*x[6]^2) + x[3]^2/(720*x[1]^2*x[4]*x[6]) + x[3]^2*x[5]^2/(720*x[2]*x[4]^2) + x[1]*x[2]*x[4]*x[6]^2/(720*x[3]^2*x[5]) + x[1]^2*x[2]*x[5]/(720*x[3]*x[4]*x[6]^2) + x[2]^2*x[3]^2*x[6]/(720*x[4]^3) + x[3]*x[4]*x[6]/(720*x[1]^3*x[2]*x[5]) + x[1]*x[2]*x[5]^3/(720*x[4]^2*x[6]^2) + x[2]^2*x[5]/(720*x[1]*x[3]*x[6]^2) + x[1]*x[3]*x[5]/(720*x[2]*x[6]^2) + x[1]^2*x[4]^2*x[6]/(720*x[3]^3*x[5]) + x[1]^2*x[4]*x[6]/(720*x[2]^2*x[3]^2) + x[2]*x[3]*x[5]/(720*x[1]^2*x[4]*x[6]^2) + x[1]^2*x[3]*x[6]/(720*x[2]*x[4]) + x[1]*x[4]^2*x[6]^2/(720*x[2]^2*x[3]^2*x[5]) + x[2]*x[3]^2/(720*x[1]^2*x[5]^2) + x[2]*x[3]/(720*x[6]) + x[2]*x[3]*x[6]/(720*x[5]) + x[1]*x[2]^2/(720*x[3]*x[4]*x[6]) + x[4]*x[6]/(720*x[1]*x[2]^2*x[5]) + x[2]*x[5]^2/(720*x[1]^2*x[4]) + x[1]*x[2]*x[5]^2/(720*x[4]*x[6]^3) + x[2]*x[3]^2*x[6]^2/(720*x[1]*x[4]*x[5]) + x[1]*x[2]^3*x[5]/(720*x[4]^2*x[6]) + x[5]^2/(720*x[3]) + x[5]^2/(720*x[3]*x[6]^3) + x[6]^3/(720*x[3]*x[5]) + x[1]^2*x[4]^2/(720*x[2]^2*x[3]^2*x[5]) + x[3]^2*x[4]/(720*x[1]^2*x[5]^2) + x[3]^2/(720*x[1]^3*x[5]) + x[5]^3/(720*x[3]*x[4]*x[6]^2) + x[5]*x[6]^2/(720*x[3]*x[4]) + x[2]*x[3]^2*x[5]^2/(720*x[1]*x[4]^3*x[6]) + x[3]*x[4]/(720*x[5]*x[6]^2) + x[1]*x[4]^2*x[6]/(720*x[2]^3*x[3]*x[5]) + x[3]*x[4]*x[6]^2/(720*x[5]^3) + x[3]*x[5]/(720*x[6]^3) + x[3]*x[6]^3/(720*x[5]^2) + x[3]/(720*x[5]^2) + x[2]*x[3]^2*x[5]*x[6]/(720*x[1]*x[4]^3) + x[3]*x[5]^3/(720*x[4]^2*x[6]) + x[3]*x[5]^2*x[6]/(720*x[4]^2) + x[1]^2*x[5]*x[6]/(720*x[2]*x[3]*x[4]) + x[2]^2*x[3]^2*x[5]^2/(720*x[1]*x[4]^3*x[6]) + x[3]*x[5]^2/(720*x[4]^2*x[6]^2) + x[3]*x[6]^2/(720*x[4]^2) + x[3]^3/(720*x[4]^2) + x[1]*x[4]*x[5]/(720*x[2]^3*x[3]) + x[4]^3/(720*x[3]^2*x[5]^2) + x[4]*x[5]^2/(720*x[3]^2*x[6]^2) + x[1]*x[2]*x[3]^2*x[5]/(720*x[4]^3) + x[4]*x[6]^2/(720*x[3]^2) + x[4]/(720*x[3]^2*x[6]) + x[4]*x[6]/(720*x[3]^2*x[5]) + x[5]/(720*x[3]^2) + x[4]^2/(720*x[5]^3) + x[3]*x[4]/(720*x[1]^3*x[6]) + x[4]/(720*x[6]^3) + x[2]*x[3]/(720*x[1]*x[4]*x[5]) + x[3]^2*x[6]/(720*x[1]^3*x[4]) + x[1]^2*x[5]^2/(720*x[2]*x[3]*x[6]) + x[3]^3/(720*x[1]^2*x[2]*x[5]) + x[4]*x[6]^3/(720*x[5]^3) + x[5]^3/(720*x[4]*x[6]^3) + x[6]^3/(720*x[4]) + x[5]^3/(720*x[4]^2) + x[2]*x[3]*x[6]/(720*x[1]*x[4]^2) + x[3]*x[4]/(720*x[1]*x[6]^2) + x[1]^2*x[2]*x[3]*x[6]/(720*x[4]^2) + x[1]*x[2]*x[3]*x[6]^2/(720*x[4]^2*x[5]) + x[1]*x[2]*x[3]*x[5]^2/(720*x[4]^3*x[6]) + x[1]*x[2]*x[3]*x[5]*x[6]/(720*x[4]^3) + x[4]^2/(720*x[1]^2*x[5]) + x[3]^3*x[5]/(720*x[1]^2*x[2]*x[4]*x[6]) + x[4]^2/(720*x[1]*x[5]*x[6]^2) + x[3]*x[4]*x[6]/(720*x[1]^3*x[5]) + x[2]*x[3]^3*x[5]/(720*x[1]^2*x[4]^2*x[6]) + x[4]^2*x[6]^2/(720*x[1]*x[5]^3) + x[4]*x[5]/(720*x[1]^2*x[6]) + x[4]*x[5]/(720*x[1]*x[6]^3) + x[4]*x[6]/(720*x[1]^2) + x[4]/(720*x[1]^3) + x[4]/(720*x[1]^2*x[6]^2) + x[3]*x[4]*x[6]^2/(720*x[1]*x[5]^2) + x[1]*x[4]/(720*x[6]^2) + x[4]*x[6]^3/(720*x[1]*x[5]^2) + x[4]*x[6]^2/(720*x[1]^2*x[5]^2) + x[3]^3*x[6]/(720*x[1]^2*x[2]*x[4]) + x[1]*x[4]*x[6]^2/(720*x[5]^2) + x[4]/(720*x[1]*x[5]^2) + x[1]^2*x[4]/(720*x[5]^2) + x[3]*x[4]/(720*x[1]*x[5]^2*x[6]) + x[1]*x[4]/(720*x[5]^2*x[6]) + x[1]*x[4]*x[6]/(720*x[5]^3) + x[1]*x[3]*x[6]^2/(720*x[2]*x[5]) + x[2]*x[4]^2/(720*x[1]*x[3]^2*x[5]) + x[2]^3/(720*x[1]*x[4]*x[6]) + x[2]^3*x[6]/(720*x[1]*x[4]*x[5]) + x[1]^3*x[2]*x[6]/(720*x[3]^2*x[5]) + x[3]/(720*x[1]*x[2]*x[5]) + x[1]*x[2]*x[3]*x[5]/(720*x[4]*x[6]^2) + x[1]^2*x[3]*x[5]/(720*x[2]*x[4]*x[6]) + x[2]^2*x[5]^2/(720*x[1]*x[3]*x[4]*x[6]) + x[5]^3/(720*x[1]*x[4]*x[6]) + x[5]^2*x[6]/(720*x[1]*x[4]) + x[5]^2/(720*x[1]^2*x[4]) + x[1]*x[5]^2/(720*x[4]) + x[3]*x[4]*x[6]/(720*x[1]*x[5]^3) + x[5]^2/(720*x[1]*x[4]*x[6]^2) + x[3]^3/(720*x[1]*x[2]*x[4]*x[6]) + x[1]^2*x[5]^2/(720*x[4]*x[6]^2) + x[6]^2/(720*x[1]*x[4]) + x[1]*x[5]^2/(720*x[4]*x[6]^3) + x[1]^2*x[6]^2/(720*x[4]) + x[1]^3/(720*x[4]) + x[1]^2/(720*x[4]*x[6]) + x[3]*x[5]/(720*x[1]^3) + x[1]^2*x[6]/(720*x[4]*x[5]) + x[1]*x[6]^3/(720*x[4]*x[5]) + x[1]*x[5]^3/(720*x[4]^2*x[6]^2) + x[1]*x[5]*x[6]^2/(720*x[4]^2) + x[4]^3/(720*x[1]*x[2]*x[3]*x[5]*x[6]) + x[1]^2*x[5]/(720*x[4]^2) + x[4]^3*x[6]/(720*x[1]*x[2]*x[3]*x[5]^2) + x[4]^2/(720*x[1]^2*x[2]*x[3]*x[6]) + x[3]^3*x[6]/(720*x[1]*x[2]*x[4]*x[5]) + x[4]^2*x[5]/(720*x[1]*x[2]*x[3]*x[6]^2) + x[3]*x[5]^2/(720*x[1]*x[4]) + x[1]*x[4]*x[5]^2/(720*x[2]^2*x[3]^2*x[6]) + x[1]*x[4]*x[5]*x[6]/(720*x[2]^2*x[3]^2) + x[3]*x[4]*x[5]/(720*x[1]^2*x[2]*x[6]^2) + x[1]*x[2]^2*x[5]^2/(720*x[3]*x[4]*x[6]^2) + x[3]^2*x[5]^2/(720*x[1]^2*x[4]*x[6]^2) + x[2]^2*x[5]*x[6]/(720*x[1]*x[3]*x[4]) + x[1]*x[3]/(720*x[2]*x[5]*x[6]) + x[1]*x[3]*x[5]*x[6]/(720*x[2]*x[4]^2) + x[2]*x[3]*x[6]/(720*x[1]^2*x[5]^2) + x[1]*x[2]*x[3]*x[6]/(720*x[5]^2) + x[1]^3*x[2]*x[5]/(720*x[3]^2*x[4]) + x[1]*x[4]^2/(720*x[2]*x[3]*x[6]) + x[4]^2*x[6]/(720*x[1]^2*x[2]*x[3]*x[5]) + x[4]^2*x[6]^2/(720*x[1]*x[2]*x[3]*x[5]) + x[4]^2/(720*x[1]*x[2]*x[3]*x[5]*x[6]) + x[1]*x[4]^2*x[6]/(720*x[2]*x[3]*x[5]) + x[1]^2*x[4]^2/(720*x[2]*x[3]*x[5]*x[6]) + x[4]^2*x[6]/(720*x[1]*x[2]*x[3]*x[5]^2) + x[1]*x[4]^2/(720*x[2]*x[3]*x[5]*x[6]^2) + x[1]*x[4]^2*x[6]^2/(720*x[2]*x[3]*x[5]^3) + x[1]^2*x[4]^2*x[6]/(720*x[2]*x[3]*x[5]^2) + x[3]*x[5]^2/(720*x[1]*x[4]*x[6]^3) + x[4]*x[5]/(720*x[1]^2*x[2]*x[3]) + x[4]*x[5]*x[6]/(720*x[1]*x[2]*x[3]) + x[4]*x[5]^2/(720*x[1]*x[2]*x[3]*x[6]) + x[4]*x[5]/(720*x[1]*x[2]*x[3]*x[6]^2) + x[1]*x[4]*x[5]/(720*x[2]*x[3]) + x[4]*x[6]^2/(720*x[1]*x[2]*x[3]*x[5]) + x[1]*x[4]*x[5]/(720*x[2]*x[3]*x[6]^3) + x[1]^2*x[4]*x[5]/(720*x[2]*x[3]*x[6]^2) + x[1]^3*x[4]/(720*x[2]*x[3]*x[5]) + x[3]^3*x[5]/(720*x[1]*x[2]*x[4]^2) + x[1]^2*x[4]*x[6]^2/(720*x[2]*x[3]*x[5]) + x[5]^2/(720*x[1]*x[2]*x[3]*x[6]) + x[1]^2*x[4]*x[6]/(720*x[2]*x[3]*x[5]^2) + x[1]*x[4]*x[6]^3/(720*x[2]*x[3]*x[5]^2) + x[1]^2*x[4]/(720*x[2]*x[3]*x[5]*x[6]) + x[3]*x[6]^3/(720*x[1]*x[4]*x[5]) + x[4]/720 + 1/(720*x[4]) + x[3]*x[4]/(720*x[1]^3*x[2]*x[6]) + x[3]*x[6]/(720*x[2]^2*x[5]) + x[3]*x[5]/(720*x[2]^2*x[4]) + x[3]*x[5]*x[6]^2/(720*x[1]*x[2]*x[4]) + x[5]*x[6]/(720*x[1]*x[2]*x[3]) + x[1]*x[5]^3/(720*x[2]*x[3]*x[4]*x[6]) + x[3]^2*x[5]/(720*x[1]^3*x[4]*x[6]) + x[3]^2*x[6]^2/(720*x[1]^2*x[4]) + x[1]*x[2]*x[4]*x[5]/(720*x[3]^2*x[6]^2) + x[3]*x[6]^3/(720*x[1]*x[2]*x[5]) + x[3]*x[4]*x[6]/(720*x[1]^2*x[2]*x[5]^2) + x[2]*x[3]*x[6]^2/(720*x[1]^2*x[5]) + x[1]*x[3]^2*x[6]/(720*x[4]*x[5]) + x[1]*x[2]*x[5]^2/(720*x[3]^2*x[4]*x[6]) + x[1]*x[3]*x[4]*x[6]/(720*x[2]*x[5]^2) + x[1]*x[3]*x[5]^2/(720*x[2]*x[4]^2*x[6]) + x[1]*x[2]*x[4]/(720*x[3]^2*x[5]*x[6]) + x[1]^2*x[2]^2*x[5]^2/(720*x[3]*x[4]^2*x[6]) + x[1]^2*x[5]*x[6]/(720*x[2]*x[3]) + x[1]^3*x[5]/(720*x[2]*x[3]*x[6]) + x[2]*x[3]*x[5]^2/(720*x[1]^2*x[4]*x[6]) + x[1]^2*x[2]^2/(720*x[3]*x[5]*x[6]) + x[2]*x[3]*x[6]/(720*x[1]^3*x[5]) + x[1]^2*x[2]^2*x[6]/(720*x[3]*x[5]^2) + x[1]*x[3]*x[5]/(720*x[2]*x[4]*x[6]^2) + x[1]^2*x[2]^2*x[5]*x[6]/(720*x[3]*x[4]^2) + x[3]*x[5]*x[6]/(720*x[1]^2*x[2]) + x[1]*x[2]^2*x[5]/(720*x[3]*x[4]^2) + x[1]*x[2]*x[4]^2*x[6]/(720*x[3]^2*x[5]^2) + x[1]^2*x[3]/(720*x[2]*x[5]),
    x[1]*x[5]/(216*x[3]^2) + x[2]*x[3]^2*x[5]/(216*x[1]*x[4]^2) + x[3]*x[5]/(216*x[1]*x[6]^2) + x[3]/(216*x[1]^2*x[6]) + x[4]*x[5]/(216*x[3]*x[6]^2) + x[2]*x[3]*x[5]/(216*x[1]^2*x[4]) + x[1]*x[4]*x[6]/(216*x[2]*x[5]^2) + x[4]^2/(216*x[3]*x[5]*x[6]) + x[5]/(216*x[2]^2) + x[4]/(216*x[2]^2*x[6]) + x[4]*x[6]/(216*x[2]^2*x[5]) + x[1]*x[4]^2*x[6]/(216*x[2]*x[3]^2*x[5]) + x[3]*x[5]/(216*x[1]^2*x[4]) + x[1]*x[2]*x[5]/(216*x[3]*x[6]) + x[3]*x[4]/(216*x[1]*x[2]^2) + x[2]*x[4]*x[6]/(216*x[1]*x[3]*x[5]) + x[6]/(216*x[1]*x[2]) + x[1]*x[2]*x[5]/(216*x[3]^2) + x[5]*x[6]/(216*x[2]*x[3]) + x[2]/(216*x[1]*x[5]) + x[3]*x[5]^2/(216*x[1]*x[2]*x[4]*x[6]) + x[2]*x[3]/(216*x[1]^2*x[6]) + x[4]*x[5]/(216*x[1]*x[2]*x[6]) + x[5]/216 + x[2]*x[3]/(216*x[1]*x[5]*x[6]) + x[2]*x[3]*x[6]/(216*x[1]*x[5]^2) + x[1]*x[2]*x[5]^2/(216*x[4]^2*x[6]) + x[3]^2*x[6]/(216*x[1]^2*x[4]) + x[3]^2*x[5]/(216*x[1]^2*x[4]*x[6]) + x[5]^2/(216*x[1]*x[4]) + x[1]^2/(216*x[5]) + x[1]*x[4]^2/(216*x[2]*x[3]^2*x[6]) + x[4]*x[5]/(216*x[1]*x[2]^2*x[6]) + x[3]*x[5]^2/(216*x[4]^2) + x[3]^2*x[5]/(216*x[1]*x[2]*x[4]) + x[1]*x[5]/(216*x[2]*x[6]^2) + x[2]*x[5]/(216*x[1]*x[3]) + x[1]*x[6]^2/(216*x[5]) + x[3]*x[6]^2/(216*x[5]^2) + x[1]*x[4]/(216*x[5]*x[6]) + x[3]^2/(216*x[1]*x[2]*x[6]) + x[1]*x[5]*x[6]/(216*x[2]*x[4]) + x[1]*x[5]*x[6]/(216*x[4]) + x[3]^2*x[6]/(216*x[1]*x[4]*x[5]) + x[4]*x[5]/(216*x[1]*x[2]*x[3]) + x[2]*x[3]*x[6]/(216*x[4]^2) + x[4]*x[6]^2/(216*x[3]*x[5]) + x[3]*x[4]/(216*x[2]*x[5]) + x[1]^2*x[2]/(216*x[3]*x[6]) + x[4]/(216*x[1]*x[3]*x[6]) + x[1]*x[2]*x[4]*x[6]/(216*x[3]^2*x[5]) + x[1]*x[5]/(216*x[2]*x[3]*x[6]) + x[1]^2*x[5]/(216*x[2]*x[3]) + x[3]*x[6]/(216*x[2]*x[4]) + x[1]^2*x[5]/(216*x[3]*x[4]) + x[3]*x[4]*x[6]/(216*x[1]*x[5]^2) + x[2]*x[6]/(216*x[1]) + x[1]*x[5]^2/(216*x[3]*x[4]) + x[4]*x[6]^2/(216*x[2]*x[3]*x[5]) + x[5]/(216*x[1]*x[2]*x[6]) + x[1]*x[2]^2/(216*x[4]) + x[4]*x[5]/(216*x[2]*x[3]*x[6]^2) + x[1]*x[2]^2*x[5]/(216*x[3]*x[4]*x[6]) + x[1]*x[2]*x[3]/(216*x[4]*x[6]) + x[1]*x[2]/(216*x[5]*x[6]) + x[3]*x[6]^2/(216*x[1]*x[2]*x[5]) + x[4]/(216*x[1]^2*x[2]) + x[1]*x[2]*x[4]/(216*x[3]^2*x[6]) + x[3]^2/(216*x[2]*x[4]) + x[1]/(216*x[4]) + x[4]/(216*x[5]^2) + x[2]^2*x[5]/(216*x[1]*x[4]*x[6]) + x[4]*x[6]^2/(216*x[1]*x[5]^2) + x[1]*x[2]/(216*x[3]*x[5]) + x[1]^2*x[4]/(216*x[2]*x[3]*x[6]) + x[1]*x[4]/(216*x[2]^2) + x[3]*x[4]/(216*x[1]*x[5]*x[6]) + x[6]^2/(216*x[4]) + x[5]^2/(216*x[4]*x[6]^2) + x[3]^2*x[5]/(216*x[1]*x[4]^2) + x[5]^2/(216*x[2]*x[6]^2) + x[3]*x[5]*x[6]/(216*x[1]*x[2]*x[4]) + x[3]*x[6]/(216*x[1]^2*x[5]) + x[1]^2*x[6]/(216*x[4]) + x[1]^2*x[5]/(216*x[4]*x[6]) + x[2]^2/(216*x[1]*x[5]) + x[2]*x[3]^2/(216*x[4]^2) + x[1]*x[5]/(216*x[6]^2) + x[1]*x[4]*x[5]/(216*x[2]^2*x[3]*x[6]) + x[4]*x[6]/(216*x[1]*x[2]^2) + x[1]*x[2]*x[6]/(216*x[3]) + x[3]*x[5]^2/(216*x[1]*x[4]*x[6]) + x[3]*x[4]*x[6]/(216*x[1]*x[2]*x[5]^2) + x[1]*x[4]/(216*x[2]*x[3]*x[5]) + x[1]^2*x[4]*x[6]/(216*x[2]*x[3]*x[5]) + x[1]*x[4]^2/(216*x[2]*x[3]*x[5]) + x[4]^2*x[6]/(216*x[1]*x[2]*x[3]*x[5]) + x[1]*x[2]*x[6]/(216*x[5]^2) + x[2]*x[3]*x[5]/(216*x[4]^2*x[6]) + x[4]^2/(216*x[2]*x[5]^2) + x[4]^2/(216*x[3]^2*x[5]) + x[3]^2/(216*x[1]^2*x[5]) + x[1]*x[6]/(216*x[2]*x[3]) + x[1]*x[5]^2/(216*x[4]*x[6]) + x[3]/(216*x[6]^2) + x[1]*x[4]*x[6]/(216*x[5]^2) + x[3]/(216*x[2]*x[5]) + x[3]*x[5]/(216*x[2]*x[4]*x[6]) + x[5]*x[6]/(216*x[3]) + x[1]*x[3]*x[5]/(216*x[2]*x[4]) + x[4]^2/(216*x[1]*x[2]^2*x[5]) + x[3]*x[5]/(216*x[1]*x[2]*x[6]^2) + x[2]*x[3]*x[5]/(216*x[1]*x[4]*x[6]^2) + x[2]*x[6]^2/(216*x[4]) + x[3]*x[6]/(216*x[2]) + x[5]^2/(216*x[3]*x[6]) + x[3]*x[5]/(216*x[2]*x[6]) + x[2]*x[5]/(216*x[1]*x[4]*x[6]) + x[1]*x[2]^2/(216*x[3]*x[5]) + x[5]^2/(216*x[2]*x[3]*x[6]) + x[3]*x[4]*x[6]/(216*x[1]^2*x[2]*x[5]) + x[1]*x[3]*x[6]/(216*x[2]*x[5]) + x[2]^2*x[3]*x[6]/(216*x[4]^2) + x[4]^2*x[6]/(216*x[3]*x[5]^2) + x[3]*x[4]/(216*x[1]*x[2]*x[5]*x[6]) + x[6]^2/(216*x[2]) + x[3]*x[5]/(216*x[1]^2*x[2]) + x[2]*x[4]/(216*x[3]*x[5]*x[6]) + x[2]^2*x[5]/(216*x[4]^2) + x[2]^2*x[6]/(216*x[4]*x[5]) + x[4]^2*x[6]/(216*x[2]*x[3]*x[5]^2) + x[4]*x[6]/(216*x[1]*x[2]) + x[4]*x[6]/(216*x[5]) + x[4]/(216*x[6]) + x[3]^2/(216*x[1]*x[4]*x[6]) + x[2]*x[3]*x[6]/(216*x[1]^2*x[5]) + x[1]*x[2]*x[4]/(216*x[3]*x[5]) + x[2]^2/(216*x[4]*x[6]) + x[2]*x[4]*x[6]/(216*x[3]*x[5]^2) + x[3]^2*x[6]/(216*x[1]*x[2]*x[5]) + x[2]*x[4]/(216*x[1]*x[3]*x[6]) + x[1]*x[6]^2/(216*x[2]*x[5]) + x[4]/(216*x[1]^2) + x[1]*x[2]*x[3]*x[5]/(216*x[4]^2) + x[2]*x[3]*x[5]*x[6]/(216*x[1]*x[4]^2) + x[2]*x[3]*x[5]^2/(216*x[1]*x[4]^2*x[6]) + x[2]*x[5]/(216*x[3]*x[6]^2) + x[1]*x[4]*x[6]/(216*x[2]*x[3]) + x[1]*x[4]*x[5]/(216*x[2]*x[3]*x[6]) + x[2]*x[3]*x[6]/(216*x[4]) + x[1]*x[2]*x[3]*x[6]/(216*x[4]*x[5]) + x[2]*x[3]^2/(216*x[1]*x[4]*x[6]) + x[1]*x[2]*x[5]*x[6]/(216*x[4]^2) + x[4]^2/(216*x[1]*x[2]*x[3]*x[6]) + x[1]^2*x[6]/(216*x[3]*x[5]) + x[1]*x[4]*x[6]/(216*x[2]^2*x[3]) + x[2]^2/(216*x[3]) + x[3]*x[5]*x[6]/(216*x[1]*x[4]) + x[1]*x[3]/(216*x[2]*x[6]) + x[4]^2/(216*x[2]^2*x[3]) + x[1]^2*x[4]/(216*x[2]*x[3]^2) + x[2]*x[3]/(216*x[4]*x[5]) + x[1]*x[4]^2/(216*x[2]^2*x[3]*x[5]) + x[4]^2/(216*x[2]*x[3]*x[5]*x[6]) + x[4]/(216*x[1]*x[2]*x[5]) + x[2]*x[3]*x[6]^2/(216*x[1]*x[4]*x[5]) + x[3]*x[4]/(216*x[1]^2*x[2]*x[6]) + x[4]/(216*x[1]*x[6]^2) + x[1]*x[4]*x[6]/(216*x[3]^2*x[5]) + x[2]*x[6]^2/(216*x[3]*x[5]) + x[2]^2*x[3]/(216*x[1]*x[4]) + x[2]*x[3]^2*x[6]/(216*x[1]*x[4]*x[5]) + x[3]*x[6]^2/(216*x[1]*x[5]) + x[1]*x[5]^2/(216*x[2]*x[4]*x[6]) + x[2]/(216*x[1]^2) + 1/(216*x[3]) + x[1]^2*x[2]/(216*x[3]^2) + x[1]^2*x[4]/(216*x[3]^2) + x[3]/(216*x[1]*x[4]) + x[1]^2*x[2]*x[6]/(216*x[3]*x[5]) + x[1]*x[2]*x[6]^2/(216*x[4]*x[5]) + x[1]*x[3]/(216*x[4]*x[6]) + x[3]*x[4]/(216*x[2]^2*x[5]) + x[3]*x[5]/(216*x[2]^2*x[6]) + x[3]*x[6]/(216*x[2]^2) + x[4]*x[5]/(216*x[3]^2*x[6]) + x[1]*x[2]^2*x[6]/(216*x[3]*x[4]) + x[2]*x[4]/(216*x[1]*x[5]) + x[1]*x[3]*x[6]/(216*x[4]*x[5]) + x[4]*x[6]/(216*x[3]^2) + x[3]^2/(216*x[4]) + x[2]*x[3]/(216*x[5]) + x[2]*x[3]*x[5]/(216*x[4]*x[6]) + x[2]*x[5]/(216*x[1]*x[6]) + x[1]*x[3]*x[5]/(216*x[4]^2) + x[2]^2*x[3]/(216*x[4]*x[5]) + x[2]^2*x[3]*x[5]/(216*x[4]^2*x[6]) + x[1]^2*x[2]*x[5]/(216*x[3]*x[4]) + x[2]*x[4]/(216*x[5]^2) + x[2]*x[5]^2/(216*x[4]*x[6]^2) + x[2]^2*x[6]/(216*x[1]*x[4]) + x[1]*x[2]*x[5]/(216*x[3]*x[4]*x[6]) + x[1]*x[2]*x[5]/(216*x[4]*x[6]^2) + x[2]*x[6]/(216*x[1]*x[4]) + x[1]*x[2]*x[6]/(216*x[3]*x[4]) + x[1]^2/(216*x[3]*x[6]) + x[1]*x[4]/(216*x[2]*x[5]*x[6]) + x[2]*x[5]^2/(216*x[3]*x[4]*x[6]) + x[1]*x[4]/(216*x[3]^2*x[6]) + x[2]*x[5]*x[6]/(216*x[3]*x[4]) + x[1]*x[4]*x[5]/(216*x[2]*x[3]^2) + x[4]^2/(216*x[1]*x[2]*x[5]) + x[4]*x[6]/(216*x[1]*x[3]*x[5]) + x[1]*x[4]*x[6]^2/(216*x[3]*x[5]^2) + x[5]/(216*x[1]*x[3]) + x[1]*x[4]/(216*x[3]*x[6]^2),x[1]/(27*x[3]) + x[5]/(27*x[3]) + x[4]*x[6]/(27*x[3]*x[5]) + x[4]/(27*x[3]*x[6]) + x[3]*x[5]/(27*x[1]*x[4]) + x[3]*x[6]/(27*x[1]*x[5]) + x[2]/(27*x[1]) + 1/(27*x[1]) + x[3]/(27*x[2]) + x[3]/(27*x[4]) + x[1]*x[2]/(27*x[3]) + x[4]/(27*x[1]*x[2]) + x[1]*x[5]/(27*x[4]) + x[1]*x[6]/(27*x[5]) + x[1]/(27*x[6]) + x[6]/27 + x[4]/(27*x[5]) + x[1]*x[4]/(27*x[2]*x[3]) + x[2]/(27*x[5]) + x[5]/(27*x[6]) + x[2]*x[5]/(27*x[4]*x[6]) + x[4]/(27*x[2]*x[5]) + x[2]*x[6]/(27*x[4]) + x[6]/(27*x[2]) + x[5]/(27*x[2]*x[6]) + x[3]/(27*x[1]*x[6]) + x[2]*x[3]/(27*x[4])]
 elif Type=E and (n=7 or n=8) then
  orb:=[seq(ZOrbit(Type,[seq(`if`(i=j,1,0),i=1..n)]),j=1..n)];
  [seq(1/nops(orb[j])*convert(map(v->convert([seq(x[i]^v[i],i=1..6)],`*`),orb[j]),`+`),j=1..n)]
 elif Type=G and n=2 then
  [x[1]/6 + x[2]/(6*x[1]) + x[1]^2/(6*x[2]) + x[2]/(6*x[1]^2) + x[1]/(6*x[2]) + 1/(6*x[1]),x[2]/6 + x[2]^2/(6*x[1]^3) + x[1]^3/(6*x[2]) + x[1]^3/(6*x[2]^2) + x[2]/(6*x[1]^3) + 1/(6*x[2])]
 else
  printf("Error: root system must be of Type A, B, C, D, F, G")
 fi;
end proc:

esp:=proc(L,r) # r-th elementary symmetric polynomials, evaluated in list L
 local f, i;
 f:=product((x_-L[i]),i=1..nops(L));
 simplify(coeff(f,x_,nops(L)-r))*(-1)^r;
end proc:

GeneralizedCosine:=proc(Type,n,u::list) # generalized cosine evaluated in u
local i, j, orb, v;
 if   Type = A then
  [seq( simplify(1/binomial(n+1,j)*esp([seq(exp(-2*Pi*I*u[i]),i=1..n+1)],j)) , j=1..n)]
 elif Type = B then
  [seq( simplify(1/binomial(n,j)*esp([seq(cos(2*Pi*u[i]),i=1..n)],j)) , j=1..n-1),simplify(esp([seq(cos(Pi*u[i]),i=1..n)],n))]
 elif Type = C then
  [seq( simplify(1/binomial(n,j)*esp([seq(cos(2*Pi*u[i]),i=1..n)],j)) , j=1..n)]
 elif Type = D then
  [seq( simplify(1/binomial(n,j)*esp([seq(cos(2*Pi*u[i]),i=1..n)],j)) , j=1..n-2),simplify(esp([seq(cos(Pi*u[i]),i=1..n)],n)-(-I)^n*esp([seq(sin(Pi*u[i]),i=1..n)],n)),simplify(esp([seq(cos(Pi*u[i]),i=1..n)],n)+(-I)^n*esp([seq(sin(Pi*u[i]),i=1..n)],n))]
 elif Type = F and n = 4 then
  [cos(Pi*u[1])*cos(Pi*u[2])/6 + cos(Pi*u[1])*cos(Pi*u[3])/6 + cos(Pi*u[1])*cos(Pi*u[4])/6 + cos(Pi*u[2])*cos(Pi*u[3])/6 + cos(Pi*u[2])*cos(Pi*u[4])/6 + cos(Pi*u[3])*cos(Pi*u[4])/6,
   cos(Pi*u[1])*cos(Pi*u[4])*cos(Pi*u[2])^2/6 + cos(Pi*u[1])*cos(Pi*u[2])*cos(Pi*u[3])^2/6 + cos(Pi*u[1])*cos(Pi*u[2])*cos(Pi*u[4])^2/6 + cos(Pi*u[1])*cos(Pi*u[4])*cos(Pi*u[3])^2/6 + cos(Pi*u[1])*cos(Pi*u[3])*cos(Pi*u[4])^2/6 + cos(Pi*u[1])^2*cos(Pi*u[2])*cos(Pi*u[3])/6 + cos(Pi*u[1])^2*cos(Pi*u[2])*cos(Pi*u[4])/6 + cos(Pi*u[1])^2*cos(Pi*u[3])*cos(Pi*u[4])/6 + cos(Pi*u[2])*cos(Pi*u[4])*cos(Pi*u[3])^2/6 + cos(Pi*u[2])*cos(Pi*u[3])*cos(Pi*u[4])^2/6 + cos(Pi*u[2])^2*cos(Pi*u[3])*cos(Pi*u[4])/6 - cos(Pi*u[1])*cos(Pi*u[2])/6 - cos(Pi*u[1])*cos(Pi*u[3])/6 - cos(Pi*u[1])*cos(Pi*u[4])/6 - cos(Pi*u[2])*cos(Pi*u[3])/6 - cos(Pi*u[2])*cos(Pi*u[4])/6 - cos(Pi*u[3])*cos(Pi*u[4])/6 + cos(Pi*u[1])*cos(Pi*u[3])*cos(Pi*u[2])^2/6,
   cos((3*Pi*u[1])/2)*cos(Pi*u[2]/2)*cos(Pi*u[3]/2)*cos(Pi*u[4]/2)/6 + cos(Pi*u[1])*cos(Pi*u[2])*cos(Pi*u[3])/12 + cos(Pi*u[1])*cos(Pi*u[2])*cos(Pi*u[4])/12 + cos(Pi*u[1])*cos(Pi*u[3])*cos(Pi*u[4])/12 + cos(Pi*u[2])*cos(Pi*u[3])*cos(Pi*u[4])/12 + cos(Pi*u[1]/2)*cos((3*Pi*u[2])/2)*cos(Pi*u[3]/2)*cos(Pi*u[4]/2)/6 + cos(Pi*u[1]/2)*cos(Pi*u[2]/2)*cos((3*Pi*u[3])/2)*cos(Pi*u[4]/2)/6 + cos(Pi*u[1]/2)*cos(Pi*u[2]/2)*cos(Pi*u[3]/2)*cos((3*Pi*u[4])/2)/6,
   cos(Pi*u[1])/12 + cos(Pi*u[2])/12 + cos(Pi*u[3])/12 + cos(Pi*u[4])/12 + (2*cos(Pi*u[1]/2)*cos(Pi*u[2]/2)*cos(Pi*u[3]/2)*cos(Pi*u[4]/2))/3]
 elif Type = E then
  orb:=[seq(ROrbit(Type,n,FWeight(E,6)[i]),i=1..n)];
  [seq(simplify(1/nops(orb[i])*convert(map(v->exp(-2*Pi*I*(<v>.<u>)),orb[i]),`+`)),i=1..n)]
 elif Type = G and n = 2 then
  [cos(2*Pi*(u[1] - u[2]))/3 + cos(2*Pi*(u[1] - u[3]))/3 + cos(2*Pi*(u[2] - u[3]))/3, cos(2*Pi*(u[1] - 2*u[2] + u[3]))/3 + cos(2*Pi*(u[1] + u[2] - 2*u[3]))/3 + cos((4*u[1] - 2*u[2] - 2*u[3])*Pi)/3]
 else
  printf("Error: root system must be of Type A, B, C, D, F, G")
 fi;
end proc:

RGeneralizedCosine:=proc(Type,n,u::list) # real generalized cosine evaluated in u
local i, j;
 if Type = A then
  [seq( simplify(GeneralizedCosine(Type,n,u)[j]+GeneralizedCosine(Type,n,u)[n+1-j])/2 , j=1..floor(n/2)) , seq(simplify(GeneralizedCosine(Type,n,u)[j]),j=ceil((n+1)/2)..floor((n+1)/2)) , seq( simplify(GeneralizedCosine(Type,n,u)[n+1-j]-GeneralizedCosine(Type,n,u)[j])/(2*I) , j=ceil((n+2)/2)..n)]
 elif Type = B or Type = C or (Type = G and n = 2) or (Type = F and n = 4) then
  GeneralizedCosine(Type,n,u)
 elif Type = D then
  if is(n::even) then 
   GeneralizedCosine(Type,n,u)
  else
   [seq(GeneralizedCosine(Type,n,u)[j],j=1..n-2),simplify((GeneralizedCosine(Type,n,u)[n]-GeneralizedCosine(Type,n,u)[n-1])/(2*I)),simplify((GeneralizedCosine(Type,n,u)[n]+GeneralizedCosine(Type,n,u)[n-1])/2)]
  fi;
 else
  printf("Error: root system must be of Type A, B, C, D, F, G")
 fi;
end proc:

VertexFundom:=proc(Type,n) # list of vertices of the fundamental domain of orthogonal Weyl group
local i, L, f;
 L:=FundomVertexCoefficient(Type,n);
 f:=FWeight(Type,n);
 if Type = A or (Type = G and n = 2) then
  [seq(f[i]/L[i],i=1..n),[seq(0,i=1..n+1)]]
 elif Type = B or Type = C or Type = D or (Type = F and n = 4) then
  [seq(f[i]/L[i],i=1..n),[seq(0,i=1..n)]]
 elif Type = E and (n=6 or n=7 or n=8) then 
  [seq(f[i]/L[i],i=1..n),[seq(0,i=1..8)]]
 fi;
end proc:

VertexTOrbitSpace:=proc(Type,n) # list of vertices of the T-orbit space
local i;
 [seq(GeneralizedCosine(Type,n,VertexFundom(Type,n)[i]),i=1..n+1)];
end proc:

RPull:=proc(Type,n,omega) option remember;
 local M, mu, L, i, v;
 M:=MatrixInverse(WeightMatrix(Type,n));
 mu:=omega;
 L:=map(v->sign(v),M.<mu>);
 while `or`(seq(is(L[i]=-1),i=1..n)) do
  for i from 1 to n do
   if L[i]=-1 then
    mu:=Reflection(Base(Type,n)[i],mu)
   fi;
  od;
  L:=map(v->sign(v),M.<mu>);
 od;
 mu;
end proc:

Pull := proc(Type,alpha) option remember;
 local n, M, mu;
 n:=nops(alpha);
 M:=WeightMatrix(Type,n);
 mu:=convert(M.<alpha>,list);
 convert(MatrixInverse(M).<RPull(Type,n,mu)>,list);
end proc:

TMultiply:=proc(Type,alpha,beta) option remember; # recurrence formula for Chebyshev polynomials associated to integer vectors alpha, beta. returns indeterminates y[...]
 local n, Tp, orb, l;
 global y;
 y:='y';
 n:=nops(alpha);
 orb:=ZOrbit(Type,beta);
 1/nops(orb)*convert(map(l->y[op(Pull(Type,alpha+l))],orb),`+`);
end proc:

MonomialMultiply:=proc(alpha,beta) # recurrence formula for standard monomial basis (just for comparisons)
 global y;
 y:='y';
 y[op(alpha+beta)];
end proc:

MonomialExponent:=proc(n,degbound)
 local LL, L, i;
 [seq(op({op(map(LL->op(combinat[permute](LL)),select(L->nops(L)=n,combinat[partition](i)))),op(map(LL->op(combinat[permute](LL-[seq(1,i=1..n)])),select(L->nops(L)=n,combinat[partition](i+n))))}),i=0..degbound)];
end proc:

MonomialExponent2:=proc(n,degbound)
 local LL, L, i;
 [seq(op({op(map(LL->op(combinat[permute](LL)),select(L->nops(L)=n,combinat[partition](i)))),op(map(LL->op(combinat[permute](LL-[seq(1,i=1..n)])),select(L->nops(L)=n,combinat[partition](i+n))))}),i=0..2*degbound)];
end proc:

ChebyshevDegExp:=proc(Type,n,l,bound) option remember;
 local i, L;
 select( L-> l*FundomVertexCoefficient(Type,n)[1] = convert([seq(L[i],i=1..n)],`+`) and convert([seq(FundomVertexCoefficient(Type,n)[1..n][i]*L[i],i=1..n)],`+`) <= bound,MonomialExponent(n,bound));
end proc:

ChebyshevLevel:=proc(Type,n,l) option remember;
 local F, L, i;
 F:=FundomVertexCoefficient(Type,n);
 if Type=F and n=4 then
  select( L-> l = convert([seq(F[1..n][i]*L[i],i=1..n)],`+`),MonomialExponent(n,l))
 else
  select( L-> l*F[1] = convert([seq(F[1..n][i]*L[i],i=1..n)],`+`),MonomialExponent(n,l))
 fi;
end proc:

TruncatedTMomentMatrix:=proc(Type,n,d) option remember; # moment matrix in Chebyshev basis up to degree degbound
 local i, j, L, l;
 L:=[seq(op(ChebyshevLevel(Type,n,l)),l=0..d)];
 Matrix(nops(L),(i,j)->TMultiply(Type,L[i],L[j]));
end proc:

TruncatedMonomialMomentMatrix:=proc(n,degbound) # moment matrix in standard monomial basis up to degree degbound
 local i, j;
 Matrix(binomial(n+degbound,n),(i,j)->MonomialMultiply(MonomialExponent2(n,degbound)[i],MonomialExponent2(n,degbound)[j]));
end proc:

TPolyRecurrence:=proc(Type,alpha) option remember; # input list with nonnegative integer entries, at least one nonzero
 local n, i, j, beta, orb, K, eq;
 n:=nops(alpha);
 j:=select(i->is(alpha[i]>0),[seq(i,i=1..n)])[1];
 beta:=[seq(`if`(i=j,1,0),i=1..n)];
 orb:=ZOrbit(Type,beta);
 K:=map(l->Pull(Type,alpha - beta + l),orb);
 eq:=convert([seq(T[op(K[i])],i=1..nops(K))],`+`);
 solve(nops(orb)*T[op(beta)]*T[op(alpha-beta)]=eq,T[op(alpha)]);
end proc:

TPoly:=proc(Type,alpha)
 option remember;
 local n, beta, i, j, index, gamma, orb, K, KK, KKK, l, k;
 n:=nops(alpha);
 global z;
 z:='z';
 if `and`(seq(is(alpha[i]=0),i=1..n)) then
  return 1
 fi;
 if `or`(seq(is(alpha[i]<0),i=1..n)) then
  beta:=Pull(Type,alpha)
 else
  beta:=alpha
 fi;
 for j from 1 to n do
  if beta[j]=1 and `and`(seq(is(beta[i]=0),i=1..j-1)) and `and`(seq(is(beta[i]=0),i=j+1..n)) then
   return z[j]
  fi;
 od;
 #Now comes the actual procedure
 index:=select(i->is(alpha[i]>0),[seq(1..n)])[1];
 gamma:=[seq(`if`(j=index,1,0),j=1..n)];
 orb:=ZOrbit(Type,gamma);
 K:=map(l->Pull(Type,beta - gamma + l),orb);
 KK:=select(k->`and`(seq(is(k[i]=beta[i]),i=1..n)),K);
 KKK:=select(k->`or`(seq(not(is(k[i]=beta[i])),i=1..n)),K);
 #eq:=convert([seq(TPoly(Type,K[i]),i=1..nops(K))],`+`);
 expand(1/nops(KK)*(nops(orb)*TPoly(Type,beta - gamma)*z[index]-convert([seq(TPoly(Type,KKK[i]),i=1..nops(KKK))],`+`)));
end proc:

#if a Groebner basis H is given by the 'Shape lemma' in permuted Variables z then the variety can be obtained by this procedure (assuming ideal is zero dimensional)
SolutionSet:=proc(H::list,permuts) option remember;
 local Sol,Solutions, i, j, k;
 Sol[1]:=[solve(H[1])];
 Solutions[1]:=map(l->[l],[op({op(Sol[1])})]);
 for k from 2 to nops(H) do
  for i from 1 to nops(Solutions[k-1]) do
   Sol[k,i]:=[op({solve(subs([seq(z[permuts[j]]=Solutions[k-1][i][j],j=1..k-1)],H[k]))})];
   Solutions[k]:=[op({seq(seq([ op(Solutions[k-1][i]) , Sol[k,i][j] ],j=1..nops(Sol[k,i])),i=1..nops(Solutions[k-1]))})];
  od:
 od:
 Solutions[nops(H)];
end proc:

HermiteMatrix:=proc(Type,n) # polynomial matrix which characterizes the T-orbit space, careful: for Type A the matrix is complex
 local Y, f, k, i, j, CompMat;
 global z;
 z:='z';
 if Type = A then
  Y:=[1,seq(z[i],i=1..n),1]:
  for k from 1 to n+1 do
   f[k]:=(-1)^k*convert([seq(binomial(n+1,i)*binomial(n+1,k-i)*Y[i+1]*Y[n-k+i+2],i=0..k)],`+`);
  od;
  CompMat:=Matrix(n+1,(i,j)-> if (i = 2 and j = 1) then 1
                              elif ((i = j+1 and j <= n) or (i = j-1 and j <= n)) then 1/2
                              elif j <= n then 0
                              elif i = 1 then -f[n+1]/4
                              elif i = n then (1-f[2])/2
                              else -f[n+2-i]/2
                              fi);
  Matrix(n+1,(i,j)->expand(Trace(CompMat^(i+j-2))-Trace(CompMat^(i+j))))
 elif Type = B then
  Y:=[seq(z[i],i=1..n)]:
  for k from 1 to n-1 do
   f[k]:=(-1)^(k+1)*binomial(n,k)*Y[k];
  od:
  f[n]:=(-1)^(n+1)*(2^n*Y[n]^2-convert([seq(binomial(n,i)*Y[i],i=1..n-1)],`+`)-1);
  CompMat:=Matrix(n,(i,j)-> if  (i = j+1 and j <= n-1) then 1
                            elif j <= n-1 then 0
                            else f[n-i+1]
                            fi):
  Matrix(n,(i,j)->expand(Trace(CompMat^(i+j-2))-Trace(CompMat^(i+j))))
 elif Type = C then
  Y:=[seq(z[i],i=1..n)]:
  for k from 1 to n do
   f[k]:=(-1)^(k+1)*binomial(n,k)*Y[k];
  od:
  CompMat:=Matrix(n,(i,j)-> if  (i = j+1 and j <= n-1) then 1
                            elif j <= n-1 then 0
                            else f[n-i+1]
                            fi):
  Matrix(n,(i,j)->expand(Trace(CompMat^(i+j-2))-Trace(CompMat^(i+j))))
 elif Type = D then
  Y:=[seq(z[i],i=1..n)]:
  for k from 1 to n-2 do
   f[k]:=(-1)^(k+1)*binomial(n,k)*Y[k];
  od:
  if is(n,even) then
   f[n-1]:=(-1)^(n)*( 2^(n-1)*Y[n]*Y[n-1]       -convert([seq(binomial(n,2*i-1)*Y[2*i-1],i=1..(n-2)/2)],`+`)   );
   f[n]  :=(-1)^(n+1)*( 2^(n-2)*(Y[n]^2+Y[n-1]^2) -convert([seq(binomial(n,2*i)  *Y[2*i]  ,i=1..(n-2)/2)],`+`) -1);
  else
   f[n-1]:=(-1)^(n)*( 2^(n-1)*Y[n]*Y[n-1]       -convert([seq(binomial(n,2*i)  *Y[2*i]  ,i=1..(n-3)/2)],`+`) -1);
   f[n]  :=(-1)^(n+1)*( 2^(n-2)*(Y[n]^2+Y[n-1]^2) -convert([seq(binomial(n,2*i+1)*Y[2*i+1],i=1..(n-3)/2)],`+`)   );
  fi:
  CompMat:=Matrix(n,(i,j)-> if  (i = j+1 and j <= n-1) then 1
                            elif j <= n-1 then 0
                            else f[n-i+1]
                            fi):
  Matrix(n,(i,j)->expand(Trace(CompMat^(i+j-2))-Trace(CompMat^(i+j))))
 elif Type = G and n = 2 then
  f[3]:=3*z[1]:
  f[2]:=-3*(z[1]+z[2])/2:
  f[1]:=(9*z[1]^2-3*z[1]-3*z[2]-1)/2:
  CompMat:=Matrix(n+1,(i,j)-> if  (i = j+1 and j <= n) then 1
                              elif j <= n then 0
                              else f[i]
                              fi):
  Matrix(n+1,(i,j)->expand(Trace(CompMat^(i+j-2))-Trace(CompMat^(i+j))))
 else
  printf("Error: root system must be of Type A, B, C, D, G")
 fi;
end proc:

RHermiteMatrix:=proc(Type,n)
 local i, j, k, f, Y, CompMat;
 global z;
 z:='z';
 if Type=B or Type=C or Type=G then
  HermiteMatrix(Type,n)
 elif Type=D and is(n,even) then
  HermiteMatrix(Type,n)
 elif Type=D and is(n,odd) then
  Y:=[seq(z[i],i=1..n)]:
  for k from 1 to n-2 do
   f[k]:=(-1)^(k+1)*binomial(n,k)*Y[k];
  od:
  f[n-1]:=(-1)^(n  )*(2^(n-1)*(Y[n]^2+Y[n-1]^2)-convert([seq(binomial(n,2*i)  *Y[2*i]  ,i=1..(n-3)/2)],`+`) -1);
  f[n]  :=(-1)^(n+1)*(2^(n-1)* Y[n]^2          -convert([seq(binomial(n,2*i+1)*Y[2*i+1],i=1..(n-3)/2)],`+`)   );
  CompMat:=Matrix(n,(i,j)-> if  (i = j+1 and j <= n-1) then 1
                            elif j <= n-1 then 0
                            else f[n-i+1]
                            fi):
  Matrix(n,(i,j)->expand(Trace(CompMat^(i+j-2))-Trace(CompMat^(i+j))))
 elif Type = G and n = 2 then
  f[3]:=3*z[1]:
  f[2]:=-3*(z[1]+z[2])/2:
  f[1]:=(9*z[1]^2-3*z[1]-3*z[2]-1)/2:
  CompMat:=Matrix(n+1,(i,j)-> if  (i = j+1 and j <= n) then 1
                              elif j <= n then 0
                              else f[i]
                              fi):
  Matrix(n+1,(i,j)->expand(Trace(CompMat^(i+j-2))-Trace(CompMat^(i+j))))
 elif Type=A then 
  Y:=[1,seq(Y||i,i=1..n),1]:
  for k from 1 to n+1 do
   f[k]:=(-1)^k*convert([seq(binomial(n+1,i)*binomial(n+1,k-i)*Y[i+1]*Y[n-k+i+2],i=0..k)],`+`);
  od;
  CompMat:=Matrix(n+1,(i,j)-> if (i = 2 and j = 1) then 1
                              elif ((i = j+1 and j <= n) or (i = j-1 and j <= n)) then 1/2
                              elif j <= n then 0
                              elif i = 1 then -f[n+1]/4
                              elif i = n then (1-f[2])/2
                              else -f[n+2-i]/2
                              fi);
  CompMat:=simplify(subs([seq(Y||k=z[k]+I*z[n+1-k],k=1..floor(n/2)),seq(Y||(n+1-k)=z[k]-I*z[n+1-k],k=1..floor(n/2))  ],CompMat));
  if is((n+1)::odd) then CompMat:=CompMat else CompMat:=subs(Y||((n+1)/2)=z[(n+1)/2],CompMat) fi;
  Matrix(n+1,(i,j)->expand(Trace(CompMat^(i+j-2))-Trace(CompMat^(i+j))))
 else
  printf("Error: root system must be of Type A, B, C, D, G")
 fi;
end proc:

InvariantRewrite:=proc(Type,n,invariant) option remember; # This proc will give an output regardless if the input is invariant or not. Input must be Laurent polynomial in x[i]
local W, TermsMatrixEntry, ExponentsMatrixEntry, SplitTermsMatrixEntry, PositiveTerms, OrbCard, i, j, k, l;
global y;
 y:='y';
 TermsMatrixEntry:=[op(expand(simplify(invariant)))];
 ExponentsMatrixEntry:=[seq([seq(degree(op(TermsMatrixEntry)[j],x[i]),i=1..n)],j=1..nops(TermsMatrixEntry))];
 SplitTermsMatrixEntry:=[seq([TermsMatrixEntry[j]*convert([seq(x[i]^(-ExponentsMatrixEntry[j][i]),i=1..n)],`*`),[seq(degree(op(TermsMatrixEntry)[j],x[i]),i=1..n)]],j=1..nops(TermsMatrixEntry))];
 PositiveTerms:=select(l->`and`(seq(is(l[2][i]>=0),i=1..n)),SplitTermsMatrixEntry);
 for i from 1 to nops(PositiveTerms) do
  OrbCard[i]:=nops(ZOrbit(Type,PositiveTerms[i,2]));
 od;
 convert([seq(PositiveTerms[i,1]*OrbCard[i]*y[op(PositiveTerms[i,2])],i=1..nops(PositiveTerms))],`+`);
end proc:

MonomialRewrite:=proc(n,invariant)
local TermsMatrixEntry, ExponentsMatrixEntry, SplitTermsMatrixEntry, i, j, k, l;
global y;
 y:='y';
 TermsMatrixEntry:=[op(expand(simplify(invariant)))];
 ExponentsMatrixEntry:=[seq([seq(degree(op(TermsMatrixEntry)[j],z[i]),i=1..n)],j=1..nops(TermsMatrixEntry))];
 SplitTermsMatrixEntry:=[seq([TermsMatrixEntry[j]*convert([seq(z[i]^(-ExponentsMatrixEntry[j][i]),i=1..n)],`*`),[seq(degree(op(TermsMatrixEntry)[j],z[i]),i=1..n)]],j=1..nops(TermsMatrixEntry))];
 convert([seq(SplitTermsMatrixEntry[i,1]*y[op(SplitTermsMatrixEntry[i,2])],i=1..nops(SplitTermsMatrixEntry))],`+`);
end proc:

THermiteEntries:=proc(Type,n,k) option remember;
local i, j;
global y;
 if Type = A then
  if is(k::odd) then
   n/2^k*(convert([seq((4*binomial(k-2,j-1)-binomial(k,j))*(y[k-2*j,seq(0,i=1..n-2)]+y[seq(0,i=1..n-2),k-2*j]),j=1..(k-1)/2)],`+`)-(y[k,seq(0,i=1..n-2)]+y[seq(0,i=1..n-2),k]) )
  else
   n/2^k*(convert([seq((4*binomial(k-2,j-1)-binomial(k,j))*(y[k-2*j,seq(0,i=1..n-2)]+y[seq(0,i=1..n-2),k-2*j]),j=1..k/2-1  )],`+`)-(y[k,seq(0,i=1..n-2)]+y[seq(0,i=1..n-2),k])
   +(4*binomial(k-2,k/2-1)-binomial(k,k/2))*y[0,seq(0,i=1..n-2)])
  fi;
 elif Type = B or Type = C or Type = D then
  if is(k::odd) then
   2*n*(convert([seq((4*binomial(k-2,j-1)-binomial(k,j))*y[k-2*j,seq(0,i=1..n-1)],j=1..(k-1)/2)],`+`)-y[k,seq(0,i=1..n-1)])
  else
   2*n*(convert([seq((4*binomial(k-2,j-1)-binomial(k,j))*y[k-2*j,seq(0,i=1..n-1)],j=1..k/2-1)],`+`)-y[k,seq(0,i=1..n-1)]+(-binomial(k,k/2)+4*binomial(k-2,k/2-1))/2*y[0,seq(0,i=1..n-1)])
  fi;
 elif Type = G then
  if is(k::odd) then
   6*(convert([seq((4*binomial(k-2,j-1)-binomial(k,j))*y[k-2*j,0],j=1..(k-1)/2)],`+`)-y[k,0])
  else
   6*(convert([seq((4*binomial(k-2,j-1)-binomial(k,j))*y[k-2*j,0],j=1..k/2-1  )],`+`)-y[k,0]+(-binomial(k,k/2)+4*binomial(k-2,k/2-1))/2*y[0,0])
  fi;
 else
  printf("Error: root system must be of Type A, B, C, D, G")
 fi;
end proc:

THermiteMatrix:=proc(Type,n)
local i, j;
global y;
 if Type = B or Type = C or Type = D then
  Matrix(n  ,(i,j)->THermiteEntries(Type,n,  i+j));
 elif Type = A then 
  Matrix(n+1,(i,j)->THermiteEntries(Type,n+1,i+j));
 elif Type = G and n = 2 then
  Matrix(3  ,(i,j)->THermiteEntries(Type,2  ,i+j));
 else
  printf("Error: root system must be of Type A, B, C, D, G")
 fi;
end proc:

RTHermiteEntriesOld:=proc(Type,n,k)
 local i, j;
 global y;
 if Type = A then
  if is(k::odd) then
   2*n/2^k*(convert([seq((4*binomial(k-2,j-1)-binomial(k,j))*(y[k-2*j,seq(0,i=1..n-2)]),j=1..(k-1)/2)],`+`)-(y[k,seq(0,i=1..n-2)]))
  else
   2*n/2^k*(convert([seq((4*binomial(k-2,j-1)-binomial(k,j))*(y[k-2*j,seq(0,i=1..n-2)]),j=1..k/2-1)],`+`)-(y[k,seq(0,i=1..n-2)])+(-binomial(k,k/2)+4*binomial(k-2,k/2-1))/2*y[0,seq(0,i=1..n-2)])
  fi;
 elif Type = B or Type = C or Type = D then
  THermiteEntries(Type,n,k)
 else
  printf("Error: root system must be of Type A, B, C, D")
 fi;
end proc:

RTHermiteEntries:=proc(n,k)
 local i, j;
 global y;
  if is(k::odd) then
   1/2^k*(convert([seq((4*binomial(k-2,j-1)-binomial(k,j))*(y[k-2*j,seq(0,i=1..n-1)]),j=1..(k-1)/2)],`+`)-(y[k,seq(0,i=1..n-1)]))
  else
   1/2^k*(convert([seq((4*binomial(k-2,j-1)-binomial(k,j))*(y[k-2*j,seq(0,i=1..n-1)]),j=1..k/2-1)],`+`)-(y[k,seq(0,i=1..n-1)])
   +(-binomial(k,k/2)+4*binomial(k-2,k/2-1))/2*y[0,seq(0,i=1..n-1)])
  fi;
end proc:

RTHermiteMatrix:=proc(Type,n)
 local i, j;
 global y;
 if Type = A or (Type=G and n=2) then 
  Matrix(n+1,(i,j)->RTHermiteEntries(n,i+j));
 elif Type = B or Type = C or Type = D then
  Matrix(n  ,(i,j)->RTHermiteEntries(n,i+j));
 else
  printf("Error: root system must be of Type A, B, C, D, G")
 fi;
end proc:

MonomialHermiteMatrix:=proc(Type,n)
 local H, L, i, entry;
 global z, x;
 x:='x';
 z:='z';
 H:=HermiteMatrix(Type,n);
 map(entry->MonomialRewrite(n,entry),H)
end proc:

CoeffInMatrix:=proc(L,Matty) option remember; # for matrices Matty with linear (or affine) entries in L
 local d, k, TTT, TTTT, ttt, t, i, j;
 d:=RowDimension(Matty);
 for i from 1 to d do
  for j from 1 to d do
   TTT[i,j]:=[coeffs(Matty[i,j],indets(Matty[i,j]),'t')]:
   TTTT[i,j]:=select(ttt->is(ttt[2]=L),[seq([TTT[i,j][k],[t][k]],k=1..nops(TTT[i,j]))]):
  od;
 od;
 Matrix(d,(i,j)->if nops(TTTT[i,j])=1 then TTTT[i,j][1][1] else 0 fi)
end proc:

MonomialLocalizedPMI:=proc(Type,n,d) option remember;
 local i, j, k, l, ll, H, Y, YH;
 global y;
 y:='y';
 YH:=MonomialExponent2(n,2*n);
 Y:=MonomialExponent2(n,d);
 H:=MonomialHermiteMatrix(Type,n);
 H:=select(ll->not(is(Rank(ll[1])=0)),map(l->[CoeffInMatrix(y[op(l)],H),l],YH));
 <seq(Transpose(<seq(convert(map(k->k[1]*y[op(Pull(Type,k[2]+Y[i]+Y[j]))],H),`+`),i=1..binomial(n+d,n))>),j=1..binomial(n+d,n))>;
end proc:

TLocalizedPMI:=proc(Type,n,d) option remember; # works for Bn, Cn, D2n
 local i, j, k, l, ll, Y, N, Orbs, H, h, yy;
 global y;
 y:='y';
 Y:=[seq(op(ChebyshevLevel(Type,n,l)),l=0..d)];
 N:=nops(Y);
 Orbs:=[seq(ZOrbit(Type,Y[i]),i=1..N)];
 #Y:=MonomialExponent(n,d)
 #Y:=[seq(op(select(yy->Transpose(WeightMatrix(Type,n).<yy>).<HighestRoot(Type,n)> = FundomVertexCoefficient(Type,n)[1]*k,Y)),k=0..d)]
 if Type = B or Type = C or Type = D then
  H:=[seq([Matrix(n,(i,j) -> if   (is(k-i-j,odd) or (k > i+j)) then 0  # following the formula for the matrix entries 
                             elif k = i+j then -1
                             elif k = 0 then 2*binomial(i+j-2,(i+j-2)/2) - 1/2*binomial(i+j,(i+j)/2)
                             else 4*binomial(i+j-2,(i+j-k)/2-1) - binomial(i+j,(i+j-k)/2)
                             fi ) , 
           [k , seq(0 , i = 2..n)]] ,
          k = 0..2*n)];
  <seq(Transpose(<seq((convert(map(h -> h[1]*(convert(map(ll->op(map(l->y[op(Pull(Type,h[2]+l+ll))],Orbs[i])),Orbs[j]),`+`)),
                                   H),`+`))/nops(Orbs[i])/nops(Orbs[j]),i=1..N)>),j=1..N)>;
 elif Type = A then
  H:=[seq([Matrix(n+1,(i,j) -> if   (is(k-i-j,odd) or (k > i+j)) then 0  # following the formula for the matrix entries 
                               elif k = i+j then -1/2^(i+j)
                               elif k = 0 then (4*binomial(i+j-2,(i+j-2)/2) - binomial(i+j,(i+j)/2))/2^(i+j+1)
                               else (4*binomial(i+j-2,(i+j-k)/2-1) - binomial(i+j,(i+j-k)/2))/2^(i+j)
                               fi ) , 
           [k , seq(0 , i = 2..n)] , [seq(0 , i = 1..n-1) , k] ] ,
          k = 0..2*n+2)];
  <seq(Transpose(<seq((convert(map(h -> h[1]*(   convert(map(ll->op(map(l->y[op(Pull(Type,h[2]+l+ll))],Orbs[i])),Orbs[j]),`+`)
                                               + convert(map(ll->op(map(l->y[op(Pull(Type,h[3]+l+ll))],Orbs[i])),Orbs[j]),`+`)),
                                   H),`+`))/nops(Orbs[i])/nops(Orbs[j]),i=1..N)>),j=1..N)>;
 elif Type = G and n = 2 then
  H:=[seq([Matrix(3,(i,j) -> if   (is(k-i-j,odd) or (k > i+j)) then 0  # following the formula for the matrix entries 
                             elif k = i+j then -1
                             elif k = 0 then 2*binomial(i+j-2,(i+j-2)/2) - 1/2*binomial(i+j,(i+j)/2)
                             else 4*binomial(i+j-2,(i+j-k)/2-1) - binomial(i+j,(i+j-k)/2)
                             fi ) , [k , 0]] , k = 0..6)];
  <seq(Transpose(<seq((convert(map(h -> h[1]*(convert(map(ll->op(map(l->y[op(Pull(Type,h[2]+l+ll))],Orbs[i])),Orbs[j]),`+`)),
                                   H),`+`))/nops(Orbs[i])/nops(Orbs[j]),i=1..N)>),j=1..N)>;
 else
  printf("Error: root system must be of Type A, B, C, D, G")
 fi;
end proc:

ChebyshevSDPdata:=proc(Type,n,d,name) option remember; #This is for the SDP solver, d must be at least n

 local Y, N, MY, MHY, M, i, k, Constraints;

 #Y:=MonomialExponent2(n,d);
 #Y:=select(yy->Transpose(WeightMatrix(Type,n).<yy>).<HighestRoot(Type,n)> <= FundomVertexCoefficient(Type,n)[1]*2*d,Y);
 Y:=[seq(op(ChebyshevLevel(Type,n,i)),i=0..2*d)];
 N:=nops(Y);
 MY:=TruncatedTMomentMatrix(Type,n,d);
 if Type = B or Type = C or Type = D then
  MHY:=TLocalizedPMI(Type,n,d-n);
 elif Type = A or Type = G then
  MHY:=TLocalizedPMI(Type,n,d-n-1);
 fi;
 M:=<<MY|Matrix(RowDimension(MY),RowDimension(MHY))>,<Matrix(RowDimension(MHY),RowDimension(MY))|MHY>>;

 Constraints := [ seq(CoeffInMatrix(y[op(Y[i])],M),i=1..N) ] ;

 Export(name,[Constraints]);
end proc:

TArchimedeanPMI:=proc(Type,n,d) option remember; # works for Bn, Cn, D2n
 local i, ii, j, l, ll, lll, k, Y, N, Orbs, ExtraOrbs, H, h, yy;
 global y;
 y:='y';
 Y:=[seq(op(ChebyshevLevel(Type,n,l)),l=0..d)];
 N:=nops(Y);
 Orbs:=[seq(ZOrbit(Type,Y[i]),i=1..N)];
 ExtraOrbs:=[seq(ZOrbit(Type,[seq(`if`(i=k,1,0),i=1..n)]),k=1..n)];
 if Type = B or Type = C or Type = D then
  <seq(
       Transpose(
                 <seq(
                      (n-(convert(
                                  [seq(
                                       (convert(
                                                map(lll->op(map(ll->op(map(l->
                                                                           y[op(Pull(Type,[seq(`if`(ii=k,1,0),ii=1..n)]+l+ll+lll))]
                                                                           ,Orbs[i])),Orbs[j])),ExtraOrbs[k])
                                                ,`+`))/nops(Orbs[i])/nops(Orbs[j])/nops(ExtraOrbs[k])
                                       ,k=1..n)]
                                  ,`+`)))
                      ,i=1..N)>
                 )
       ,j=1..N)>;
 else
  printf("Error: root system must be of Type B, C, D")
 fi;
end proc:

ChebyshevArchimedeanSDP:=proc(Type,n,d,name) option remember; #This is for the SDP solver, d must be at least n
 local dH, dP, Y, N, MY, MHY, MPY, nY, nHY, nPY, M, i, k, Constraints;
 dP:=max(FundomVertexCoefficient(Type,n))/FundomVertexCoefficient(Type,n)[1];
 dH:=n;
 Y:=[seq(op(ChebyshevLevel(Type,n,i)),i=0..2*d)];
 N:=nops(Y);
 MY:=TruncatedTMomentMatrix(Type,n,d);
 if Type=B or Type=C or Type=D then
  MHY:=TLocalizedPMI(Type,n,d-dH);
  MPY:=TArchimedeanPMI(Type,n,d-dP);
 else
  printf("Error: root system must be of Type B, C, D")
 fi;
 nY :=RowDimension(MY);
 nHY:=RowDimension(MHY);
 nPY:=RowDimension(MPY);
 M:=<<MY|Matrix(nY,nHY)|Matrix(nY,nPY)>,<Matrix(nHY,nY)|MHY|Matrix(nHY,nPY)>,<Matrix(nPY,nY)|Matrix(nPY,nHY)|MPY>>;

 Constraints := [ seq(CoeffInMatrix(y[op(Y[i])],M),i=1..N) ] ;

 Export(name,[Constraints]);
end proc:

end module: #GeneralizedChebyshevNULL;

